# 23장. **실행 컨텍스트(Execution Context)**

**실행 컨테스트의 정의:**
: 실행 컨텍스트(Execution Context)는 **JavaScript 코드의 실행 환경**을 나타내는 개념입니다.
- 코드의 실행에 필요한 모든 정보를 담고 있으며, 변수, 함수, 매개변수 등의 데이터와 실행에 필요한 규칙을 포함합니다.
- 실행 컨텍스트는 JavaScript 엔진이 코드를 실행하는 동안 생성되고 관리됩니다.

**실행 컨테스트의 내부 구조:**
실행 컨텍스트는 크게 세 가지 구성 요소로 이루어져 있습니다.
1. **Variable Environment (변수 환경)**:
   - **현재 컨텍스트에서 선언된 변수, 함수 선언 등의 정보를 저장**합니다.
   - 변수와 함수 선언에 대한 식별자와 값, this 값을 포함합니다.
   - **환경 레코드(Environment Record)와 외부 렉시컬 환경 참조(Outer Lexical Environment Reference)로 구성됩니다.**
2. **Lexical Environment (렉시컬 환경)**:
   - 렉시컬 환경은 변수 환경을 감싸는 환경으로, **스코프 체인과 클로저를 구현하는 데 사용**됩니다.
   - **스코프 체인은 현재 컨텍스트의 변수 환경과 외부 렉시컬 환경 참조를 연결하여 변수 및 함수에 대한 검색 순서를 결정합니다.**
   - **환경 레코드(Environment Record)와 외부 렉시컬 환경 참조(Outer Lexical Environment Reference)로 구성됩니다.**
3. **This Binding (this 바인딩)**:
   - 현재 실행 중인 코드 내에서 this 키워드가 참조하는 객체를 결정합니다.
   - this 바인딩은 실행 컨텍스트가 생성될 때 결정되며, 함수 호출 방식에 따라 달라집니다.
   - 실행 컨텍스트는 코드의 실행이 시작될 때 생성되고, **콜스택(Call Stack)**에 쌓입니다. JavaScript 엔진은 콜스택을 사용하여 현재 실행 중인 컨텍스트를 추적하고, 함수 호출과 반환을 관리합니다. 코드의 실행이 완료되면 해당 컨텍스트는 콜스택에서 제거됩니다.

**Variable Environment와 Lexical Environment의 구성과 차이**
- Variable Environment과 Lexical Environment은 각각 환경 레코드(Environment Record)와 외부 렉시컬 환경 참조(Outer Lexical Environment Reference)로 구성됩니다.
   - **환경 레코드(Environment Record)**: 현재 실행 컨텍스트에서 선언된 변수, 함수 선언 등을 기록하는 객체입니다. 변수와 함수에 대한 실제 바인딩이 여기에 저장됩니다.
   - **외부 렉시컬 환경 참조(Outer Lexical Environment Reference)**: 현재 실행 컨텍스트의 상위 스코프(외부 함수, 전역 스코프 등)를 참조하는 링크입니다.
- 이 두 환경의 가장 큰 차이점은 변수 및 함수의 범위를 어떻게 관리하느냐에 따라 결정됩니다.
  - Variable Environment는 현재 실행 중인 코드 블록에 대한 변수 및 함수 선언을 저장하는 공간입니다. 이는 함수 내부의 변수 및 함수 선언과 그 범위를 관리합니다.
  - Lexical Environment는 변수 및 함수가 정의된 위치에 따라 결정되는 환경을 나타냅니다.이는 변수와 함수의 스코프 및 클로저를 관리합니다.


<br>

**[목차]**
- 23장. 실행 컨텍스트
  - [23-1. 소스코드의 타입](#23-1-소스코드의-타입)
  - [23-2. 소스코드의 평가와 실행](#23-2-소스코드의-평가와-실행)
  - [23-3. 실행 컨텍스의 역할](#23-3-실행-컨텍스의-역할)
    - [전역 코드 평가](#전역-코드-평가)
    - [전역 코드 실행](#전역-코드-실행)
    - [함수 코드 평가](#함수-코드-평가)
    - [함수 코드 실행](#함수-코드-실행)
  - [23-4. 실행 컨텍스트 스택(Execution Context Stack)](#23-4-실행-컨텍스트-스택execution-context-stack)
  - [23-5. 렉시컬 환경(Lexical Environment)](#23-5-렉시컬-환경lexical-environment)
  - [23-6. 실행 컨텍스트의 생성과 식별자 검색과정](#23-6-실행-컨텍스트의-생성과-식별자-검색과정)
  - [23-7. 실행 컨텍스트와 블록 레벨 스코프](#23-7-실행-컨텍스트와-블록-레벨-스코프)
  - [요약](#요약)
  - [키워드](#키워드)
  - [Reference](#reference)

<br>

## 23-1. 소스코드의 타입
ECMA Script는 다음 4가지 타입(전역 코드, 함수 코드, Eval 코드, 모듈 코드)의 소스 코드에 따라 실행 컨텍스트를 생성합니다:
1. **전역 코드(Global code)**:
    - 전역 스코프에서 실행되는 코드입니다.
    - 스크립트 파일이 로드되면 가장 먼저 전역 코드의 실행 컨텍스트가 생성됩니다.
    - 이 컨텍스트는 전역 변수와 함수를 포함하며, 전역 스코프 체인의 최상위에 위치합니다.
    - `var` 키워드로 선언된 전역 변수와 함수 선언문으로 선언된 전역 함수는 전역 객체의 프로퍼티와 메서드로 바인딩되고 참조됩니다. 이를 위해 전역 실행 컨텍스트가 생성됩니다.
2. **함수 코드(Function code)**:
    - 함수 내에서 실행되는 코드입니다.
    - 함수가 호출될 때마다 해당 함수의 실행 컨텍스트가 생성됩니다.
    - 함수 코드는 지역 스코프를 생성하고 해당 스코프에서 지역 변수, 매개 변수, arguments 객체 등을 관리해야 합니다. 이를 위해 함수 실행 컨텍스트가 생성됩니다.
    - 함수 코드의 실행 컨텍스트는 함수 내의 지역 변수, 매개변수, 내부 함수를 포함하며, 해당 함수의 스코프 체인을 형성합니다.
4. **모듈 코드(Module code)**:
    - ECMAScript 모듈 시스템에서 사용되는 코드입니다.
    - 모듈은 독립적인 실행 컨텍스트를 가지며, 모듈 내에서 선언된 변수와 함수는 해당 모듈 스코프 내에서만 유효합니다.
    - 모듈 코드는 `import` 및 `export` 문을 사용하여 모듈 간에 데이터 및 기능을 공유할 수 있습니다.
3. **Eval 코드(Eval code)**:
    - `eval()` 함수를 통해 실행되는 동적인 코드입니다.
    - `eval()` 함수는 문자열로 표현된 JavaScript 코드를 실행합니다.
    - eval 코드는 `strict mode`에서 자신만의 독립적인 스코프를 생성합니다. 이를 위해 eval 코드가 평가되면 eval 실행 컨텍스트가 생성됩니다.
    - eval 코드의 실행 컨텍스트는 `eval()` 함수가 호출될 때마다 생성됩니다.

**각각의 소스 코드 타입은 실행 컨텍스트를 생성하는 과정과 내용에서 차이가 있습니다.** 예를 들어, 전역 코드의 실행 컨텍스트는 스크립트 파일이 로드될 때 한 번만 생성되지만, 함수 코드의 실행 컨텍스트는 해당 함수가 호출될 때마다 생성됩니다. 
또한, **스코프 체인은 각 실행 컨텍스트의 범위를 나타내며, 해당 소스 코드 타입에 따라 형성됩니다.**  소스 코드의 타입에 따라 실행 컨텍스트를 구분하는 이유는 각 타입에 맞게 변수 및 함수의 스코프, 식별자 해결 방식 등을 관리하기 위해서입니다. 이를 통해 JavaScript 엔진은 코드 실행을 정확하게 추적하고, 올바른 변수와 함수를 참조할 수 있습니다.

```jsx
// 1. 전역 코드 (Global Code)
var globalVariable = 'Global Variable';

function globalFunction() {
  console.log('Global Function');
}

console.log(globalVariable);
globalFunction();

// 2. 함수 코드 (Function Code)
function myFunction() {
  var localVariable = 'Local Variable';
  console.log(localVariable);
}

myFunction();

// 3. 모듈 코드 (Module Code)****
// 모듈 파일: myModule.js
export const moduleVariable = 'Module Variable';
export function moduleFunction() {
  console.log('Module Function');
}

// 메인 파일: main.js
import { moduleVariable, moduleFunction } from './myModule.js';
console.log(moduleVariable);
moduleFunction();

// 4. Eval 코드 (Eval Code)
var evalCode = 'var x = 10; console.log(x);';
eval(evalCode);
```

<br>

## 23-2. 소스코드의 평가와 실행
자바스크립트 엔진은 소스 코드 평가(Evaluation)와 소스 코드 실행(Execution)을 분리하여 처리합니다.

1. **소스 코드 평가(Evaluation)**
    - 실행 컨텍스트 생성: 소스 코드 평가 과정에서는 실행 컨텍스트(Execution Context)가 생성됩니다.
    - **스코프 생성: 생성된 실행 컨텍스트 내에서 스코프(Scope)가 생성됩니다. 스코프는 변수와 함수의 유효 범위를 나타냅니다.**
    - 변수 및 함수 선언문 실행: 소스 코드 평가 단계에서는 변수 선언문(`var`, `let`, `const`)과 함수 선언문이 실행되어 스코프 내에 등록됩니다. 이때 변수나 함수 식별자가 스코프에 등록되어 식별할 수 있게 됩니다.
2. **소스 코드 실행(Execution)**
    - 소스 코드 실행: 소스 코드 실행 과정에서는 소스 코드의 실제 실행이 이루어집니다. 소스 코드의 문들이 순차적으로 실행되며, 변수 값의 변경, 함수 호출 등의 동작이 실행됩니다.
    - 스코프 검색: 소스 코드 실행 중에는 변수나 함수의 참조가 필요한 경우, 해당 참조를 실행 컨텍스트가 관리하는 스코프 내에서 검색합니다. 스코프 체인을 통해 상위 스코프로 올라가며 참조를 검색하고, 해당 값에 접근하여 사용합니다.
    - 실행 결과 등록: 소스 코드 실행 결과(변수 값 변경, 반환 값 등)은 다시 실행 컨텍스트가 관리하는 스코프에 등록됩니다. 이를 통해 다음 실행 단계에서 해당 값에 접근할 수 있습니다.

이렇게 소스 코드 평가 과정에서는 변수와 함수의 선언문이 먼저 실행되어 스코프에 등록되고, 소스 코드 실행 과정에서는 등록된 변수나 함수에 접근하여 사용됩니다. 이러한 과정을 통해 자바스크립트 엔진은 소스 코드를 평가하고 실행하여 동작을 수행합니다.

```jsx
// 전역 변수
var x = 100; // (초기값)

function beforeExecution() {
  console.log('beforeExecution 안에서:', x);
}

function afterExecution() {
    // 지역 변수
    var x = 200;
    console.log('afterExecution 안에서:', x);
    beforeExecution();
}

// 평가 단계:
// 평가 단계에서 변수와 함수 선언이 처리되고 실행 컨텍스트가 설정됩니다. 
console.log('실행 전:', x); // 출력: 실행 전: 100
afterExecution();

// 실행 단계:
// 실행 단계에서는 코드가 순차적으로 실행됩니다.
console.log('실행 후:', x); // 출력: 실행 후: 100
```
> `afterExecution`를 호출하면 지역 변수 x의 값(200)이 출력되고, 그 후에 `beforeExecution`가 호출되어 전역 변수 x의 값(100)이 출력됩니다.


<br>

## 23-3. 실행 컨텍스트의 역할:
1. **변수와 함수의 스코프 및 렉시컬 환경 관리**: 실행 컨텍스트는 변수 및 함수의 스코프를 결정하고 렉시컬 환경을 생성하여 변수와 함수에 대한 접근을 제어합니다.
2. **this 값 바인딩:** 실행 컨텍스트는 this 키워드가 현재 실행 중인 코드 내에서 참조하는 객체를 결정합니다.
3. **변수 및 함수의 호이스팅 관리**: 실행 컨텍스트는 변수와 함수 선언을 끌어올려(hoist) 해당 스코프의 맨 위로 이동시켜 선언 단계와 초기화 단계를 분리하고, 코드 실행 전에 해당 식별자에 대한 메모리 공간을 할당합니다.
4. **스코프 체인 구성**: 실행 컨텍스트는 스코프 체인을 구성하여 변수 및 함수에 대한 검색 순서를 결정하고, 클로저를 지원합니다.
5. **코드 실행 및 관리**: 실행 컨텍스트는 코드 실행을 추적하고, 콜스택을 관리하여 함수 호출 및 반환을 추적하고 코드 실행 흐름을 관리합니다.


```jsx
// 예제 23-2

// 전역 변수 선언
const a = 1;
const b = 2;

// 함수 정의
function Sum(x){
    // 지역 변수 선언
    const a = 10;
    const b = 20;

    // 메서드 호출
    console.log(x + a + b); // 130
}

// 함수 호출
Sum(100)

// 메서드 호출
console.log(a + b); // 3
```

<br>

### 전역 코드 평가
- 전역 코드를 평가하는 과정에서는 선언문(변수 선언문, 함수 선언문 등)만 먼저 실행되고, 실행 컨텍스트에 등록됩니다.
- 전역 코드 평가 과정에서 전역 변수와 함수는 전역 실행 컨텍스트의 변수 객체에 등록되며, 전역 객체와 연결됩니다. 이후에 다른 함수나 스코프에서 전역 변수와 함수에 접근할 때는 전역 객체를 통해 접근할 수 있습니다.

**[전역 코드 평가 과정]**
1. 전역 실행 컨텍스트 생성: 전역 코드 평가를 위해 전역 실행 컨텍스트가 생성됩니다.
2. 변수 및 함수 선언문 실행: 전역 실행 컨텍스트에서는 변수 선언문(`var`, `let`, `const`)과 함수 선언문이 실행되어 변수와 함수가 등록됩니다. 이때 `var` 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티와 메서드가 됩니다.
3. 전역 함수 실행: 전역 코드의 실행은 변수와 함수의 선언문 실행이 끝나면 시작됩니다. 따라서 전역 함수는 실행되며, 전역 변수는 선언된 값을 가지고 있게 됩니다.

<br>

### 전역 코드 실행
- 전역 코드의 평가 과정이 끝나면 런타임(Runtime)이 시작되어 전역 코드가 순차적으로 실행됩니다. 
- 전역 변수에 값이 할당되고 함수가 호출됩니다.
- 함수가 호출되면 현재 실행 중이던 전역 코드의 실행을 일시 중단하고, 코드 실행 순서를 변경하여 함수 내부로 진입합니다. 이를 함수 `호출(Call)`이라고 합니다.

**[호출 발생 과정]**
1. 함수 실행 컨텍스트 생성: 호출된 함수에 대한 실행 컨텍스트가 생성됩니다. 이 컨텍스트에는 함수 내부의 변수 및 매개 변수가 등록됩니다.
2. 실행 컨텍스트 스택에 함수 실행 컨텍스트 추가: 함수 실행 컨텍스트가 실행 컨텍스트 스택의 맨 위에 추가됩니다. 이로써 현재 실행 중인 컨텍스트는 일시 중단됩니다.
3. 함수 내부 코드 실행: 함수 내부 코드가 순차적으로 실행됩니다. 함수 내부에서 새로운 변수의 선언, 연산, 다른 함수 호출 등이 이루어집니다.
4. 함수 실행 종료: 함수 내부 코드의 실행이 완료되면 해당 함수 실행 컨텍스트는 실행 컨텍스트 스택에서 제거됩니다.
5. 이전 실행 컨텍스트로 돌아가기: 이전 실행 컨텍스트(전역 실행 컨텍스트나 다른 함수 실행 컨텍스트)로 돌아가서 코드의 실행을 이어갑니다.

<br>

### 함수 코드 평가 
- 함수 호출로 인해 코드 실행 순서가 변경되어 함수 내부로 진입할 때, 함수 코드 평가 과정이 실행되어 함수 코드를 실행하기 위한 준비가 이루어집니다.
- 함수 코드 평가 과정을 거치면 함수 내부의 매개 변수와 지역 변수가 등록되고, 함수 내에서 사용할 수 있는 `arguments` 객체가 생성되며 `this` 바인딩도 결정됩니다.

**[함수 코드 평가 과정]**
1. 함수 실행 컨텍스트 생성: 함수 코드 평가를 위해 함수 실행 컨텍스트가 생성됩니다.
2. 매개 변수와 지역 변수 선언문 실행: 함수 실행 컨텍스트에서는 매개 변수와 지역 변수 선언문이 실행되어 매개 변수와 지역 변수가 등록됩니다. 이때 매개 변수와 지역 변수는 실행 컨텍스트가 관리하는 지역 스코프에 등록됩니다.
3. `arguments` 객체 생성: 함수 내부에서 사용할 수 있는 `arguments` 객체가 생성되고, 지역 스코프에 등록됩니다. `arguments` 객체는 함수 내에서 인자 값들을 배열 형태로 제공하며, 함수 내에서 인자 값에 접근하고 조작할 수 있는 기능을 제공합니다.
4. `this` 바인딩 결정: 함수 실행 컨텍스트에서 `this` 바인딩이 결정됩니다. `this`는 함수가 호출될 때 함수가 어떻게 호출되었는지에 따라 달라지는 특수한 식별자입니다. 실행 컨텍스트의 일부로서 함수 호출에 따라 적절한 `this` 값을 설정합니다.

<br>

### 함수 코드 실행
- 함수 코드 평가 과정이 완료되면 런타임(Runtime)이 시작되어 함수 코드가 순차적으로 실행됩니다. 이때 매개 변수와 지역 변수에 값이 할당되고 `console.log` 메서드가 호출됩니다.
  - `console.log` 메서드를 호출하기 위해서는 먼저 식별자인 `console`을 스코프 체인을 통해 검색해야 합니다. 함수 코드의 지역 스코프는 상위 스코프인 전역 스코프와 연결되어야 합니다. 그러나 `console` 식별자는 스코프 체인에 등록되어 있지 않고 전역 객체의 프로퍼티로 존재합니다. 이는 전역 객체의 프로퍼티가 마치 전역 변수처럼 전역 스코프를 통해 검색 가능해야 한다는 것을 의미합니다. 따라서 `console.log` 메서드를 호출하기 위해 `console` 식별자를 전역 스코프에서 검색합니다. 그 후 `console.log` 메서드에 전달된 표현식인 `x + a + b`가 평가됩니다.
- 실행 컨텍스트는 스코프를 구분하여 식별자와 값의 바인딩을 관리합니다. 스코프 체인을 형성하여 식별자를 검색할 수 있으며, 전역 객체의 프로퍼티도 전역 변수처럼 검색할 수 있어야 합니다.
- 함수 호출이 종료되면 함수 호출 이전의 실행 코드로 돌아가기 위해 현재 실행 중인 코드와 이전에 실행했던 코드를 구분하여 관리해야 합니다. 이를 위해 실행 컨텍스트 스택을 사용하여 실행 컨텍스트를 관리합니다. 실행 컨텍스트 스택을 통해 함수 호출과 반환을 처리하며, 코드의 실행 순서를 관리합니다.


<br>

실행 컨텍스트는 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프(Scope)와 코드 실행 순서를 관리하는 내부 메커니즘으로 모든 코드는 실행 컨텍스트를 통해 실행되고 관리됩니다.

1. **스코프(Scope)**
   - 스코프는 식별자를 관리하고 변수나 함수를 검색하기 위한 중요한 메커니즘입니다.
   - 스코프는 실행 컨텍스트의 렉시컬 환경(Lexical Environment)으로 관리됩니다.
     - 렉시컬 환경은 변수와 함수 식별자를 저장하고 스코프 체인을 형성하는데 사용됩니다.
     - 렉시컬 환경은 식별자의 유효 범위를 결정하며, 변수와 함수에 대한 접근을 가능하게 합니다.
2. **실행 컨텍스트 스택(Execution Context Stack)**
   - 실행 컨텍스트 스택(Execution Context Stack)은 코드 실행 순서를 관리하는 메커니즘입니다.
   - 실행 컨텍스트 스택은 실행 중인 코드의 실행 컨텍스트들을 관리하며, 함수의 호출과 반환에 따라 컨텍스트를 스택에 `push`하거나 `pop`합니다.
   - 택의 맨 위에 있는 실행 컨텍스트가 현재 실행 중인 컨텍스트이며, 이전 컨텍스트로 돌아가면서 코드의 실행 흐름을 제어합니다.

<br>

## 23-4. 실행 컨텍스트 스택(Execution Context Stack):
- **스택(Execution Context Stack)은 실행 컨텍스트를 관리하는 자료구조**로, 코드의 실행 순서와 관련된 정보를 저장하고 제어합니다.
  - 스택(Stack)은 후입선출(LIFO, Last-In-First-Out) 방식으로 동작하며, 가장 최근에 추가된 실행 컨텍스트가 가장 먼저 제거되는 구조입니다.

**[실행 컨텍스트 스택(Execution Context Stack) 동작 과정]**
1. 전역 실행 컨텍스트 추가:
     - 코드 실행이 시작되면 가장 먼저 전역 실행 컨텍스트가 실행 컨텍스트 스택에 추가됩니다. 이는 전역 코드의 실행을 관리하는 실행 컨텍스트를 생성하고 스택에 추가하는 과정입니다.
2. 함수 호출시 실행 컨텍스트 추가:
     - 함수가 호출되면 해당 함수에 대한 실행 컨텍스트가 생성되고, 실행 컨텍스트 스택의 맨 위에 추가됩니다. 이렇게 하여 함수의 실행을 관리하며, 함수 내부에서 다른 함수가 호출되는 경우에도 실행 컨텍스트가 추가됩니다. 이 과정은 중첩된 함수 호출이 발생할 때마다 반복됩니다.
3. 실행 컨텍스트 제거:
     - 함수 실행이 완료되면 해당 함수에 대한 실행 컨텍스트는 실행 컨텍스트 스택에서 제거됩니다. 이렇게 하여 이전 실행 컨텍스트로 돌아가고, 코드의 실행을 이어나갈 수 있습니다. 함수가 반환되면 해당 함수의 실행 컨텍스트를 스택에서 제거하고 이전 실행 컨텍스트로 돌아가는 것이 일반적인 동작입니다.

```jsx
// 예제 23-3
const x = 1;

function foo (){
  const y = 2;
  
  function bar(){
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}

foo();
```
> 위의 코드를 실행하면 `6`이라는 결과가 출력될 것입니다. 이는 전역 변수 `x`에 값 `1`이 할당되고, 함수 `foo`가 호출되어 지역 변수 `y`에 값 `2`가 할당되며, 함수 `bar`가 호출되어 지역 변수 `z`에 값 `3`이 할당되었기 때문입니다. `console.log(x + y + z)`에서는 전역 변수 `x`, 함수 `foo`의 지역 변수 `y`, 함수 `bar`의 지역 변수 `z`를 참조하여 합을 출력합니다.

**[실행 컨텍스트 스택 형성 과정]**
1. 전역 실행 컨텍스트 생성:
   - 전역 변수 `x`가 선언되고 값 1이 할당됩니다.
2. 함수 `foo` 실행 컨텍스트 생성:
   - 함수 `foo` 호출에 의해 실행 컨텍스트 스택에 `foo`의 실행 컨텍스트가 추가됩니다.
   - 지역 변수 `y`가 선언되고 값 2가 할당됩니다.
3. 함수 `bar` 실행 컨텍스트 생성:
   - 함수 `bar` 호출에 의해 실행 컨텍스트 스택에 `bar`의 실행 컨텍스트가 추가됩니다.
   - 지역 변수 `z`가 선언되고 값 3이 할당됩니다.
4. `console.log(x + y + z)` 실행:
   - 실행 컨텍스트 스택의 맨 위에 있는 `bar`의 실행 컨텍스트에서 `console.log` 문이 실행됩니다.
   - `x`, `y`, `z`를 참조하여 값 6이 출력됩니다.
5. 함수 `bar` 실행 컨텍스트 제거:
   - `bar` 함수의 실행이 완료되었으므로 해당 실행 컨텍스트가 실행 컨텍스트 스택에서 제거됩니다.
6. 함수 `foo` 실행 컨텍스트 제거:
   - `foo` 함수의 실행이 완료되었으므로 해당 실행 컨텍스트가 실행 컨텍스트 스택에서 제거됩니다.
7. 전역 실행 컨텍스트 제거:
   - 전역 코드의 실행이 완료되었으므로 해당 실행 컨텍스트가 실행 컨텍스트 스택에서 제거됩니다.

**실행 중인 실행 컨텍스트(running execution context)**
- 실행 컨텍스트 스택에서 맨 위에 위치한 실행 컨텍스트가 실행 중인 실행 컨텍스트입니다.
- 실행 중인 실행 컨텍스트(Running Execution Context)는 현재 실행되고 있는 코드의 실행 컨텍스트를 가리킵니다.
- 실행 중인 실행 컨텍스트는 현재 실행 중인 코드의 컨텍스트 정보와 해당 코드에서 사용되는 변수, 함수 등의 식별자와 그에 대한 값들을 관리합니다.
- 실행 중인 실행 컨텍스트는 실행 컨텍스트 스택의 맨 위에 위치하며, 실행 컨텍스트 스택에서 다른 실행 컨텍스트로 전환될 때까지 계속 실행됩니다. 함수 호출이 발생하면 해당 함수에 대한 실행 컨텍스트가 생성되고 실행 중인 실행 컨텍스트 위에 추가됩니다. 함수 실행이 완료되면 해당 실행 컨텍스트가 스택에서 제거되고, 이전 실행 컨텍스트로 돌아가서 실행을 이어나갑니다.
- 실행 중인 실행 컨텍스트는 코드의 실행 흐름을 제어하고, 식별자의 검색 및 값의 할당, 함수 호출 및 반환 등을 처리합니다.

<br>

## 23-5. 렉시컬 환경(Lexical Environment)
- 렉시컬 환경(Lexical Environment)은 식별자(변수, 함수, 클래스 등의 이름)와 그에 대응하는 값, 그리고 스코프 체인을 관리하는 내부 구조체입니다. 
**- 자바스크립트 엔진은 실행 컨텍스트마다 렉시컬 환경을 생성하여 코드의 실행에 필요한 정보를 저장하고 검색합니다.**
- 렉시컬 환경은 스코프 체인을 형성하여 변수의 유효 범위를 관리하고, 코드 실행 중에 식별자 검색과 값의 할당을 수행합니다.
- **레시컬 환경 구성 요소:**
    1. **환경 레코드(Environment Record)**: 식별자와 그에 대응하는 값(변수, 함수, 클래스 등)을 등록하고 관리하는 영역입니다. 환경 레코드는 두 가지 형태로 구성될 수 있습니다.
      - 더 일반적인 경우, 환경 레코드는 실제 식별자와 값을 매핑하는 내부 구조체입니다. 이는 변수와 그 값을 저장하고, 함수 및 클래스 선언을 처리하는 데 사용됩니다.
      - 함수의 경우, 환경 레코드는 해당 함수의 매개 변수와 인수 값을 매핑합니다.
    2. **외부 렉시컬 환경 참조(Outer Lexical Environment Reference)**: 현재 렉시컬 환경이 포함된 외부(상위) 스코프(함수, 전역 등)의 렉시컬 환경을 참조합니다. 이를 통해 스코프 체인을 형성하고, 식별자 검색을 위해 외부 렉시컬 환경으로 이동할 수 있습니다.

```jsx
function outer() {
  const x = 10;

  function inner() {
    const y = 20;
    console.log(x + y);
  }

  inner();
}

outer();
```
> `outer` 함수와 `inner` 함수는 각각 자신의 렉시컬 환경을 가지고 있습니다. `outer` 함수의 렉시컬 환경에는 변수 `x`가 등록되어 있고, `inner` 함수의 렉시컬 환경에는 변수 `y`가 등록되어 있습니다. 함수 `inner` 내부에서 `console.log(x + y)`를 실행할 때, `x`와 `y` 변수는 렉시컬 환경에서 검색됩니다. `y`는 현재 렉시컬 환경에 등록되어 있는 지역 변수이므로 값을 찾아내고, `x`는 현재 렉시컬 환경에는 없지만 외부 렉시컬 환경 참조를 통해 상위 스코프인 `outer` 함수의 렉시컬 환경에서 값을 찾아냅니다. 따라서 `console.log(x + y)`의 결과는 `30`이 출력됩니다.

**[코드 실행 과정]**
1. 전역 실행 컨텍스트:
    - 전역 렉시컬 환경 생성
    - `outer` 함수 정의 등록
    - `outer` 함수 호출
2. `outer` 함수 실행 컨텍스트:
    - `outer` 렉시컬 환경 생성
    - `x` 변수 선언 및 값 할당: `10`
    - `inner` 함수 정의 등록
    - `inner` 함수 호출
3. `inner` 함수 실행 컨텍스트:
    - `inner` 렉시컬 환경 생성
    - `y` 변수 선언 및 값 할당: `20`
    - `console.log(x + y)` 실행: `30`

<br>

## 23-6. 실행 컨텍스트의 생성과 식별자 검색과정
```jsx
// 예제 23-4
var x = 1;
const y =  2;

function foo(a){
    var x = 3;
    const y = 4;

    function bar(b){
        const z = 5;
        console.log( a + b + x + y + z);
    }
    bar(10);
}

foo(20)
```
1. 전역 실행 컨텍스트 생성:
    - 전역 객체 생성
    - 전역 변수 `x` 선언 및 값 할당: `1`
    - 전역 상수 `y` 선언 및 값 할당: `2`
    - 함수 `foo` 정의 등록
    - 전역 코드 실행
2. `foo` 함수 실행 컨텍스트 생성:
    - `foo` 함수의 렉시컬 환경 생성
    - 매개 변수 `a` 선언 및 값 할당: `20`
    - 지역 변수 `x` 선언 및 값 할당: `3`
    - 지역 상수 `y` 선언 및 값 할당: `4`
    - 함수 `bar` 정의 등록
    - `bar` 함수 호출
3. `bar` 함수 실행 컨텍스트 생성:
    - `bar` 함수의 렉시컬 환경 생성
    - 매개 변수 `b` 선언 및 값 할당: `10`
    - 지역 상수 `z` 선언 및 값 할당: `5`
    - `console.log(a + b + x + y + z)` 실행: `42`
4. `console.log` 문 내부에서 식별자 검색:
    - `a`는 현재 렉시컬 환경에서 찾을 수 없으므로 외부 렉시컬 환경 참조를 따라 전역 렉시컬 환경까지 이동하여 값을 찾습니다.
    - `b`는 현재 렉시컬 환경에서 찾을 수 없으므로 외부 렉시컬 환경 참조를 따라 `foo` 함수의 렉시컬 환경까지 이동하여 값을 찾습니다.
    - `x`는 현재 렉시컬 환경에서 찾을 수 있으므로 현재 렉시컬 환경에서 값을 찾습니다.
    - `y`는 현재 렉시컬 환경에서 찾을 수 없으므로 외부 렉시컬 환경 참조를 따라 전역 렉시컬 환경까지 이동하여 값을 찾습니다.
    - `z`는 현재 렉시컬 환경에서 값을 찾습니다.
5. `console.log(a + b + x + y + z)`의 결과인 `42`가 출력됩니다.
6. `bar` 함수 실행 종료: `bar` 함수의 실행 컨텍스트가 실행 컨텍스트 스택에서 제거됩니다.
7. `foo` 함수 실행 종료: `foo` 함수의 실행 컨텍스트가 실행 컨텍스트 스택에서 제거됩니다.
8. 전역 코드 실행 종료:
    - 전역 코드의 실행이 완료되었으므로 전역 실행 컨텍스트가 실행 컨텍스트 스택에서 제거됩니다.

<br>

## 23-7. 실행 컨텍스트와 블록 레벨 스코프
- 실행 컨텍스트는 블록 레벨 스코프를 구현하는 데 사용됩니다.
- `var` 키워드로 선언한 변수는 함수 레벨 스코프를 따르며, `let`과 `const` 키워드로 선언한 변수는 블록 레벨 스코프를 따릅니다.
  - 함수 레벨 스코프(Function-Level Scope)는 변수가 함수 내에서만 유효하며, 함수 내에서 선언된 변수는 해당 함수의 블록을 벗어나면 접근할 수 없습니다.
  - 블록 레벨 스코프(Block-Level Scope)를 따르는 let과 const로 선언한 변수는 모든 코드 블록에서 유효합니다.

```jsx
// 예제 23-11
let x = 1;

if(true){
    x = 10;
    console.log(x)
}

console.log(x)
```
> `if` 문의 블록 내에서 `x`에 할당된 값(10)은 블록 외부에서도 접근 가능합니다. 이는 `let`으로 선언된 변수 `x`가 블록 레벨 스코프를 따르기 때문입니다. 따라서 `if` 문의 블록 내에서 `x`에 할당된 값(1)이 블록 외부에서도 유지되며, `console.log(x)` 문에서 해당 값(10)을 출력합니다.

**[실행 컨텍스트와 블록 레벨 스코프의 동작]**
1. 전역 실행 컨텍스트 생성:
    - 전역 변수 `x` 선언 및 값 할당: `1`
    - 전역 코드 실행
2. `if` 문의 블록 실행 컨텍스트 생성:
    - `if` 문의 블록 렉시컬 환경 생성
    - `x` 변수에 값 할당: `10`
    - `console.log(x)` 실행: `10`
3. `console.log(x)` 문에서 식별자 `x`를 검색:
    - `x`는 현재 블록 렉시컬 환경에서 찾을 수 있으므로 현재 블록 렉시컬 환경에서 값을 찾습니다.
4. `console.log(x)`의 결과인 `10`이 출력됩니다.
5. `if` 문의 블록 실행 종료: `if` 문의 블록 실행 컨텍스트가 실행 컨텍스트 스택에서 제거됩니다.
6. `console.log(x)` 문에서 식별자 `x`를 검색:
    - `x`는 현재 블록 렉시컬 환경에서 찾을 수 없으므로 외부 렉시컬 환경 참조를 따라 전역 렉시컬 환경까지 이동하여 값을 찾습니다.
7. `console.log(x)`의 결과인 `10`이 출력됩니다.

<br>

## 요약

- 소스 코드 타입에 따라 실행 컨텍스트가 생성됩니다.
- **[소스 코드 타입]**
  1. 전역 코드 (Global Code): 전역 실행 컨텍스트가 생성되고, 전역 변수와 함수가 전역 실행 컨텍스트의 변수 객체에 등록됩니다.
  2. 함수 코드 (Function Code): 함수 실행 컨텍스트가 생성되고, 함수 내부의 지역 변수가 해당 실행 컨텍스트의 변수 객체에 등록됩니다.
  3. Eval 코드 (Eval Code): eval 실행 컨텍스트가 생성되고, eval 코드 내의 변수가 해당 실행 컨텍스트의 변수 객체에 등록됩니다.
  4. 모듈 코드 (Module Code): 모듈 실행 컨텍스트가 생성되고, 모듈 코드 내에서 선언된 변수와 함수가 해당 실행 컨텍스트의 변수 객체에 등록됩니다. 모듈 코드는 모듈 파일과 메인 파일로 구성되며, import와 export 문을 사용하여 모듈 간 상호 작용이 이루어집니다.
- 소스 코드의 평가(Evaluation)와 실행(Execution) 단계가 분리되어 처리됩니다.
- **[소스 코드의 단계]**
   1. 평가 단계: 이 단계에서 자바스크립트 엔진은 소스 코드를 평가하고 변수와 함수 선언을 처리합니다. 실행 컨텍스트를 설정하고 변수와 함수를 각각의 스코프에 등록합니다.
   2. 실행 단계: 평가 단계가 끝나면 실행 단계가 시작됩니다. 자바스크립트 엔진은 코드를 순차적으로 실행하며, 연산을 수행하고 필요한 경우 변수 값을 업데이트합니다.
- 실행 컨텍스트를 통해 코드의 실행과 관련된 정보를 관리하고, 스코프와 실행 컨텍스트 스택을 통해 식별자와 코드 실행 순서를 관리합니다.
- 실행 컨텍스트 스택을 사용하여 함수의 호출과 반환을 관리함으로써 코드의 실행 순서를 제어합니다. 현재 실행 중인 컨텍스트는 스택의 맨 위에 위치하며, 함수 호출이 발생하면 해당 함수에 대한 실행 컨텍스트가 추가되고, 함수 실행이 완료되면 해당 실행 컨텍스트가 제거됩니다. 이를 통해 코드의 실행 흐름을 관리하고 함수 호출과 반환을 처리할 수 있습니다.

<br>

## 키워드
- 소스 코드
- 전역 코드
- 함수 코드
- eval 코드
- 모듈 모드
- 평가 단계
- 실행 단계
- 실행 컨텍스트
- 실행 컨텍스트 스택
- 렉시컬 환경
- 블록 레벨 스코프
- 함수 레벨 스코프

<br>


## Reference
- [eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)
- [Function.prototype.call()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call)