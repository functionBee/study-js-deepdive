# 23. 실행 컨텍스트

실행 컨텍스트(execution context)는 자바스크립트의 동작 원리를 담고 있는 핵심 개념입니다. 

- 실행 컨텍스트를 바르게 이해하면 다음에 해당하는 동작 방식을 이해할 수 있습니다.
  
  - 스코프를 기반으로 식별자와 식별자에 바인딩된 값을 관리하는 방식
  - 호이스팅이 발생하는 이유
  - 클로저의 동작 방식
  - 이벤트 핸들러의 동작 방식
  - 비동기 처리의 동작 방식

<br/>

## 23-1. 소스코드의 타입

ECMAScript 사양은 소스코드를 4가지 타입으로 구분합니다. 소스코드의 타입에 따라 실행 컨텍스트를 생성하는 과정과 관리 내용이 다릅니다.

- **전역 코드**
  - 전역에 존재하는 소스코드
  - 전역에 정의된 함수, 클래스 등의 내부 코드 제외
  - 전역 변수를 관리하기 위해 최상위 스코프인 전역 스코프를 생성해야 합니다.
  - `var` 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩하고 참고하기 위해 전역 객체와 연결되어야 합니다.
  - 이를 위해 전역 코드가 평가되면 전역 실행 컨텍스트가 생성됩니다.

- **함수 코드**
  - 함수 내부에 존재하는 소스코드
  - 함수 내부 중첩 함수, 클래스 등의 내부 코드 제외
  - 지역 스코프를 생성하고 지역 변수, 매개변수, arguments 객체를 관리해야 합니다.
  - 생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결해야 합니다.
  - 이를 위해 함수 코드가 평가되면 함수 실행 컨텍스트가 생성됩니다.

- **eval 코드**
  - 빌트인 전역 함수인 `eval` 함수에 인수로 전달되어 실행되는 소스코드
  - `strict mode`에서 자신만의 독자적인 스코프를 생성합니다.
  - 이를 위해 eval 코드가 평가되면 `eval` 실행 컨텍스트가 생성됩니다.

- **모듈 코드**
  - 모듈 내부에 존재하는 소스코드
  - 모듈 내부의 함수, 클래스 등의 내부 코드 제외
  - 모듈별로 독립적인 모듈 스코프를 생성합니다.
  - 이를 위해 모듈 코드가 평가되면 모듈 실행 컨텍스트가 생성됩니다.

<br/>

## 23-2. 소스코드의 평가와 실행

자바스크립트 엔진은 소스코드를 2개의 과정으로 나누어 처리합니다.

- **소스코드의 평가**
  - 실행 컨텍스트를 생성하고 변수, 함수 등의 선언문만 먼저 실행하여 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록합니다.

- **소스코드의 실행**
  - 소스코드의 평가 과정이 끝나면 선언문을 제외한 소스코드가 순차적으로 실행되기 시작합니다. 즉, 런타임이 시작됩니다.
  - 이때 소스코드 실행에 필요한 정보, 즉 변수나 함수의 참조를 실행 컨텍스트가 관리하는 스코프에서 검색해서 취득합니다.
  - 그리고 변수 값의 변경 등 소스코드의 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록됩니다.

- **예시**
  ```jsx
  var x;
  x = 1;
  ```
  
  - 소스코드 평가
    - `var x;`를 실행합니다.
    - 생성된 변수 식별자 `x`는 실행 컨텍스트가 관리하는 스코프에 등록되고 `undefined`로 초기화됩니다.

    ![image](https://github.com/gather-around-and-code/study-js-deepdive/assets/67141218/bbae27b3-acf0-4488-bd7e-a6b5502c33f8)


  - 소스코드의 실행
     - 변수 선언문 `var x;`는 소스코드 평가 과정에서 이미 실행이 완료되었습니다.
     - 변수 할당문 `x = 1;`을 실행합니다.
     - 변수에 값을 할당하기 위해 `x` 변수가 선언된 변수인지 확인하기 위해, 실행 컨텍스트가 관리하는 스코프에 `x` 변수가 등록되어 있는지 확인합니다.
     - `x` 변수가 실행 컨텍스트가 관리하는 스코프에 등록되어 있다면 `x` 변수는 선언된 변수입니다.
     - 따라서  값을 할당하고 할당 결과를 실행 컨텍스트에 등록하여 관리합니다.
     
     ![image](https://github.com/gather-around-and-code/study-js-deepdive/assets/67141218/fc3864b0-a985-42ec-bf12-d18a53f562c8)

<br/>

## 23-3. 실행 컨텍스트의 역할

- **자바스크립트 엔진의 소스코드 평가와 실행 과정**

  ```jsx
  // 전역 변수 선언
  const x = 1;
  const y = 2;

  // 함수 정의
  function foo(a) {
    // 지역 변수 선언
    const x = 10;
    const y = 20;

    // 메서드 호출
    console.log(a + x + y); // 130
  }

  // 함수 호출
  foo(100);

  // 메서드 호출
  console.log(x + y);
  ```

  **1. 전역 코드 평가**
    - 전역 코드 평가 과정을 거치며 전역 코드를 실행하기 위한 준비를 합니다.
    - 전역 코드의 변수, 함수 선언문이 먼저 실행됩니다.
    - 그 결과 생성된 전역 변수와 전역 함수가 실행 컨텍스트가 관리하는 전역 스코프에 등록됩니다.
    - `var` 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티와 메서드가 됩니다.

  **2. 전역 코드 실행**
    - 전역 코드 평가 과정이 끝나면 런타임이 시작되어 전역 코드가 순차적으로 실행됩니다.
    - 전역 변수에 값 할당되고 함수가 호출됩니다.
    - 함수가 호출되면 순차적으로 실행되던 전역 코드의 실행을 일시 중단하고 코드 실행 순서를 변경하여 함수 내부로 진입합니다.

  **3. 함수 코드 평가**
    - 함수 호출에 의해 코드 실행 순서가 변경되어 함수 내부로 진입하면 함수 코드 평가 과정을 거치며 함수 코드를 실행하기 위한 준비를 합니다.
    - 매개변수와 지역 변수 선언문이 먼저 실행됩니다.
    - 그 결과 생성된 매개변수와 지역 변수가 실행 컨텍스트가 관리하는 지역 스코프에 등록됩니다.
    - 함수 내부에서 지역 변수처럼 사용할 수 있는 `arguments` 객체가 생성되어 지역 스코프에 등록되고 `this` 바인딩도 결정됩니다.

  **4. 함수 코드 실행**
    - 함수 코드 평가 과정이 끝나면 런타임이 시작되어 함수 코드가 순차적으로 실행됩니다.
    - 매개변수와 지역 변수에 값이 할당되고 `console.log` 메서드가 호출됩니다.
    - `console.log` 메서드 호출을 위해 `console`을 스코프 체인을 통해 검색합니다.
      - 이를 위해 함수 코드의 지역 스코프는 전역 스코프와 연결되어야 합니다.
      - `console`은 스코프 체인에 등록되어 있지 않고 전역 객체에 프로퍼티로 존재합니다. 
      - 따라서 전역 객체의 프로퍼티는 마치 전역 변수처럼 전역 스코프를 통해 검색 가능해야 합니다.
    - `log` 프로퍼티를 `console` 객체의 프로토타입 체인을 통해 검색합니다.
    - 그 후 `console.log` 메서드에 인수로 전달된 `a + x + y`가 평가됩니다. `a`, `x`, `y` 식별자는 스코프 체인을 통해검색합니다.
    - `console.log` 메서드의 실행이 종료되면 함수 코드 실행 과정이 종료되고 함수 호출 이전으로 되돌아가 전역 코드 실행을 계속합니다.

- **코드가 실행되려면 스코프, 식별자, 코드 실행 순서 등의 관리가 필요합니다.**
  - 선언에 의해 생성된 모든 식별자(변수, 함수, 클래스 등)를 스코프를 구분해 등록하고 상태 변화(식별자에 바인딩된 값의 변화)를 지속적으로 관리할 수 있어야 합니다.
  - 스코프는 중첩 관계에 의해 스코프 체인을 형성해야 합니다. 즉 스코프 체인을 통해 상위 스코프로 이동하여 식별자를 검색할 수 있어야 하고, 전역 객체의 프로퍼티도 전역 변수처럼 검색할 수 있어야 합니다.
  - 현재 실행 중인 코드와 이전에 실행하던 코드를 구분해 관리함으로써 현재 실행 중인 코드의 실행 순서를 변경할 수 있어야 하며 다시 되돌아갈 수도 있어야 합니다.

- **실행 컨텍스트는 앞서 말한 모든 것을 관리합니다.**
  
  - 실행 컨텍스트는 소스코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역입니다.
  - 실행 컨텍스트는 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와, 코드 실행 관리를 구현한 내부 매커니즘입니다.
  - 모든 코드는 실행 컨텍스트를 통해 실행되고 관리됩니다.
    
    > - 식별자와 스코프 : 실행 컨텍스트의 **렉시컬 환경**으로 관리
    > - 코드 실행 순서 : **실행 컨텍스트 스택**으로 관리

<br/>

## 23-4. 실행 컨텍스트의 스택

자바스크립트 엔진이 생성한 실행 컨텍스트는 스택 자료구조로 관리됩니다. 이를 실행 컨텍스트 스택이라고 합니다.

- **실행 컨텍스트 스택**
  - 실행 컨텍스트 스택은 코드의 실행 순서를 관리합니다.
  - 소스코드가 평가되면 실행 컨텍스트가 생성되고 실행 컨텍스트 스택의 최상위에 쌓입니다.
  - 실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트는 언제나 현재 실행 중인 코드의 실행 컨텍스트입니다.
  - 따라서 실행 컨텍스트의 최상위에 존재하는 실행 컨텍스트를 '실행 중인 실행 컨텍스트'라 합니다.

- **자바스크립트 엔진의 실행 컨텍스트 관리**

  ```jsx
  // 전역 코드와 함수 코드로 이뤄진 코드입니다.
  const x = 1;

  function foo() {
    const y = 2;

    function bar() {
      const z = 3;
      console.log(x + y + z);
    }
    bar();
  }
  foo(); // 6
  ```

  ![image](https://github.com/gather-around-and-code/study-js-deepdive/assets/67141218/430ec734-2cba-4021-9298-d98ca5bef31c)
  
  **1. 전역 코드의 평가와 실행**
    - 전역 코드 평가
    - 전역 실행 컨텍스트 생성
    - 실행 컨텍스트 스택에 push
    - 전역 변수 `x`와 전역 함수 `foo`는 전역 실행 컨텍스트에 등록
    - 전역 코드가 실행되기 시작하여 전역 변수 `x`에 값 할당, 전역 함수 `foo` 호출

  **2. `foo` 함수 코드의 평가와 실행**
    - 전역 코드 실행 일시 중단
    - 코드의 제어권이 `foo` 함수 내부로 이동
    - `foo` 함수 코드 평가
    - `foo` 함수 실행 컨텍스트 생성
    - 실행 컨텍스트 스택에 push
    - 지역 변수 `y`와 중첩 함수 `bar`를 `foo` 함수 실행 컨텍스트에 등록
    - `foo` 함수 코드가 실행되기 시작하여 지역 변수 `y`에 값 할당, 중첩 함수 `bar` 호출

  **3. `bar` 함수 코드의 평가와 실행**
    - `foo` 함수 코드 실행 일시 중단
    - 코드의 제어권이 `bar` 함수 내부로 이동
    - `bar` 함수 코드 평가
    - `bar` 함수 실행 컨텍스트 생성
    - 실행 컨텍스트 스택에 push
    - 지역 변수 `z`를 함수 실행 컨텍스트에 등록
    - `bar` 함수 코드가 실행되기 시작하여 지역 변수 `z`에 값 할당, `console.log` 메서드 호출
    - `bar` 함수 종료

  **4. `foo` 함수 코드로 복귀**
    - `bar` 함수가 종료되어 코드 제어권이 다시 `foo` 함수로 이동
    - `bar` 함수 실행 컨텍스트를 실행 컨텍스트 스택에서 pop하여 제거
    - `foo` 함수 종료

  **5. `foo` 함수 실행 컨텍스트를 실행 컨텍스트 스택에서 pop하여 제거**
   - `foo` 함수가 종료되어 코드 제어권이 다시 전역 코드로 이동
   - `foo` 함수 실행 컨텍스트를 실행 컨텍스트 스택에서 pop하여 제거

<br/>

## 23-5. 렉시컬 환경

렉시컬 환경(Lexical Environment)은 식별자와 식별자에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트입니다.

> **실행 컨텍스트는 `LexicalEnvironment` 컴포넌트와 `VariableEnvironment` 컴포넌트로 구성됩니다.**
> <br/>
  > - 생성 초기에 `LexicalEnvironment` 컴포넌트와 `VariableEnvironment` 컴포넌트는 하나의 동일 한 렉시컬 환경을 참조합니다.
  > - 이후 몇 가지 상황을 만나면 `VariableEnvironment` 컴포넌트를 위한 새로운 렉시컬 환경을 생성하고,
    이때부터 `VariableEnvironment` 컴포넌트와 `LexicalEnvironment` 컴포넌트는 내용이 달라지는 경우도 있습니다.
> <br/>
> 이 책에서는 특수한 상황을 제외하고 두 컴포넌트를 구분하지 않고 렉시컬 환경으로 통일해 설명합니다.

<br/>

- **키와 값을 갖는 객체 형태의 스코프를 생성해 식별자를 키로 등록하고 식별자에 바인딩된 값을 관리합니다.**
  - 즉, 스코프를 구분해 식별자를 등록하고 관리하는 저장소 역할을 하는 렉시컬 스코프의 실체입니다.

- **렉시컬 환경은 환경 레코드와 외부 렉시컬 환경에 대한 참조로 구성됩니다.**
    
    - **환경 레코드**
      - 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값은 관리하는 저장소입니다.
      - 소스코드의 타입에 따라 관리하는 내용에 차이가 있습니다.
    
    - **외부 렉시컬 환경에 대한 참조**
      - 상위 스코프를 가리킵니다. (상위 스코프란 외부 렉시컬 환경, 즉 해당 실행 컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경을 말합니다.)
      - 단방향 링크드 리스트인 스코프 체인을 구현합니다.

<br/>

## 23-6. 실행 컨텍스트의 생성과 식별자 검색 과정

```jsx
var x = 1;
const y = 2;

function foo(a) {
  var x = 3;
  const y = 4;

  function bar(b) {
    const z = 5;
    console.log(a + b + x + y + z);
  }
  bar(10);
}

foo(20);
```

<br/>

### 23-6-1. 전역 객체 생성

- 전역 객체는 전역 코드가 평가되기 이전에 생성됩니다.
- 전역 객체에는 빌트인 전역 프로퍼티, 빌트인 전역 함수, 표준 빌트인 객체 추가됩니다.
- 동작 환경에 따라 클라이언트 사이드 Web API 또는 특정 환경을 위한 호스트 객체를 포함합니다.
- 전역 객체도 `Object.prototype`을 상속받습니다. 즉, 전역 객체도 프로토타입 체인의 일원입니다.

<br/>

### 23-6-2. 전역 코드 평가

- 소스코드가 로드되면 자바스크립트 엔진은 전역 코드를 평가합니다.

> **전역 코드 평가 순서**
> 1. 전역 실행 컨텍스트 생성
> 2. 전역 렉시컬 환경 생성
>> - 2.1. 전역 환경 레코드 생성
>>> - 2.1.1. 객체 환경 레코드 생성
>>> - 2.1.2. 선언적 환경 레코드 생성
>> - 2.2. `this` 바인딩
>> - 2.3. 외부 렉시컬 환경에 대한 참조 결정

**1. 전역 실행 컨텍스트 생성**
- 비어있는 전역 실행 컨텍스트를 생성하여 실행 컨텍스트 스택에 push합니다.
- 이때 전역 실행 컨텍스트는 실행 중인 실행 컨텍스트가 됩니다.

**2. 전역 렉시컬 환경 생성**
- 전역 렉시컬 환경을 생성하고 전역 실행 컨텍스트에 바인딩합니다.
  ![image](https://github.com/gather-around-and-code/study-js-deepdive/assets/67141218/c02f54c0-4a0c-4927-8ce1-d4ede174a8a1)

**2.1 전역 환경 레코드 생성**
- 전역 변수를 관리하는 전역 스코프, 전역 객체의 빌트인 전역 프로퍼티와 빌트인 전역함수, 표준 빌트인 객체를 제공합니다.
- `var`, `let`, `const` 키워드로 선언한 전역 변수를 구분하여 관리하기 위해 객체 환경 레코드와 선언적 환경 레코드로 구성됩니다.

  - **객체 환경 레코드**
    > - `var` 키워드로 선언한 전역 변수와 함수 선언문으로 정의한 전역 함수, 빌트인 전역 프로퍼티와 빌트인 전역 함수, 표준 빌트인 객체를 관리합니다.
    > - 객체 환경 레코드는 `BindingObject`라고 부르는 객체와 연결됩니다. 이때 `BindingObject`는 전역 객체 생성에서 생성된 전역 객체입니다.
    > - 전역 코드 평가 과정에서 `var` 키워드로 선언한 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 환경 레코드의 객체 환경 레코드에 연결된
   `BindingObject`를 통해 전역 객체의 프로퍼티와 메서드가 됩니다.
    > - 등록된 식별자를 객체 환경 레코드에서 검색하면 전역 객체의 프로퍼티에서 검색하여 반환합니다.

    ```jsx
    var x = 1;
    const y = 2;

    function foo(a) {
    ...
    ```
    
    ![image](https://github.com/gather-around-and-code/study-js-deepdive/assets/67141218/d440ec2a-11ac-4125-aa78-158ac7278726)

    - `var` 키워드로 선언된 전역변수 `x`와 함수 선언문으로 정의된 전역 함수 `foo`가 전역 객체의 프로퍼티와 메서드가 됩니다.
    - 전역 객체를 가리키는 식별자 `window` 없이 전역 객체의 프로퍼티를 참조할 수 있습니다.
    - 변수 호이스팅과 함수 호이스팅
      - `x` 변수는 전역 코드 평가 시점에 객체 환경 레코드에 바인딩된 `BindingObject`를 통해 전역 객체에 변수 식별자를 키로 등록한 다음, 암묵적으로 `undefined`를 바인딩합니다.
        (`var` 키워드로 선언한 변수에 할당한 함수 표현식도 동일하게 동작합니다.) 따라서 변수 선언문 이전에도 참조할 수 있으나, 값은 언제나 `undefined`입니다.
      - 함수 선언문으로 정의한 함수가 평가되면 함수 이름과 동일한 이름의 식별자를 객체 환경 레코드에 바인딩된 `BindingObject`를 통해 전역 객체의 키로 등록하고 생성된 함수 객체를 즉시 할당합니다. 
        따라서 함수 선언문으로 정의한 함수는 코드 실행 단계에서 함수 선언문 이전에 호출할 수 있습니다.

  - **선언적 환경 레코드**
    > - `let`, `const` 키워드로 선언한 전역 변수를 관리합니다.
    > - `let`, `const` 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 되지 않고 전역 환경 레코드의 선언적 환경 레코드내에 존재합니다.
  
    ```jsx
    var x = 1;
    const y = 2;

    function foo(a) {
    ...
    ```
    
    ![image](https://github.com/gather-around-and-code/study-js-deepdive/assets/67141218/630123b7-61da-4648-8822-3b7b7183be49)
    
   -  변수 `y`는 전역 객체의 프로퍼티가 되지 않기 때문에 `window.y`와 같이 전역 객체의 프로퍼티로서 참조할 수 없습니다.
   -  `const` 키워드로 선언한 변수는 선언 단계와 초기화 단계가 분리되어 진행합니다.
      따라서 초기화 단계, 즉 런타임에 실행 흐림이 변수 선언문에 도달하기 전까지 **일시적 사각지대(TDZ)**에 빠지게 됩니다.
   - `let`, `const` 키워드로 선언한 변수도 변수 호이스팅이 발생하지만, 런타임에 컨트롤이 변수 선언문에 도달하기 전까지 TDZ에 빠지기 때문에 참조할 수 없습니다.
    
**2.2 `this` 바인딩**
- 전역 환경 레코드의 `[[GlobalThisValue]]` 내부 슬롯에 `this`가 바인딩됩니다.
- 일반적으로 전역 코드에서 `this`는 전역 객체이므로 `[[GlobalThisValue]]` 내부 슬롯은 전역 객체가 바인딩됩니다.
- 전역 코드에서 `this`를 참조하면 전역 환경 레코드의 `[[GlobalThisValue]]` 내부 슬롯에 바인딩 되어있는 객체가 반환됩니다.

![image](https://github.com/gather-around-and-code/study-js-deepdive/assets/67141218/6f82caf7-e713-4f58-b780-c5b572ce9bff)


**2-3. 외부 렉시컬 환경에 대한 참조 결정**

> - 외부 렉시컬 환경에 대한 참조는 현재 평가 중인 소스코드를 포함하는 외부 소스코드의 렉시컬 환경, 즉 상위 스코프를 가리킵니다.
> - 이를 통해 단방향 링크드 리스트인 스코프 체인을 구현합니다.

![image](https://github.com/gather-around-and-code/study-js-deepdive/assets/67141218/5b10be3f-b0d9-446f-9017-052b84ac7a4e)

- 현재 평가 중인 소스코드는 전역 코드이고, 전역 코드를 포함하는 소스코드는 없으므로 전역 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 `null`이 할당됩니다.
- 전역 렉시컬 환경이 스코프 체인의 종점에 존재함을 의미합니다.

<br/>

### 23-6-3. 전역 코드 실행

![image](https://github.com/gather-around-and-code/study-js-deepdive/assets/67141218/6bc72873-e4ed-4cb2-b4ba-385f4352d4e8)


- 전역 코드가 순차적으로 실행되기 시작합니다.
- 실행 중인 실행 컨텍스트인 전역 실행 컨텍스트에서 식별자 `x`, `y`, `foo`를 검색합니다.
  - 만약 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색할 수 없으면 상위 스코프로 이동하여 식별자를 검색합니다.
  - 전역 렉시컬 환경은 스코프 체인의 종점이므로 전역 렉시컬 환경에서 검색할 수 없는 식별자는 참조 에러를 발생시킵니다.
- 전역 변수 `x`, `y`에 값이 할당됩니다. 그리고 `foo` 함수가 호출됩니다.

> **식별자 결정**
> - 변수 할당문 또는 함수 호출문을 실행하려면 먼저 변수 또는 함수 이름이 선언된 식별자를 확인해야 합니다.
> - 이때 동일한 이름의 식별자가 다른 스코프에 여러개 존재할 수 있으므로 어느 스코프의 식별자를 참조할지 결정하는 것을 말합니다.

<br/>

### 23-6-4. `foo` 함수 코드 평가

```jsx
var x = 1;
const y = 2;

function foo(a) {
  var x = 3;
  const y = 4;

  function bar(b) {
    const z = 5;
    console.log(a + b + x + y + z);
  }
  bar(10);
}

foo(20);
```

`foo` 함수가 호출되면 전역 코드의 실행을 일시 중단하고 `foo` 함수 내부로 코드의 제어권이 이동합니다. 그리고 함수 코드를 평가하기 시작합니다.

> **함수 코드 평가 순서**
  > 1. 함수 실행 컨텍스트 생성
  > 2. 함수 렉시컬 환경 생성
  >> - 2.1. 함수 환경 레코드 생성
  >> - 2.2. `this` 바인딩
  >> - 2.3. 외부 렉시컬 환경에 대한 참조 결정

**1. 함수 실행 컨텍스트 생성**
- `foo` 함수 실행 컨텍스트를 생성하여 실행 컨텍스트 스택에 push합니다.
- 이때 `foo` 함수 실행 컨텍스트는 실행 중인 실행 컨텍스트가 됩니다.

**2. 함수 렉시컬 환경 생성**
- `foo` 함수 렉시컬 환경을 생성하고 전역 실행 컨텍스트에 바인딩합니다.

**2.1 함수 환경 레코드 생성**
- 매개변수, `arguments` 객체, 함수 내부에서 선언한 지역 변수와 중첩 함수를 등록하고 관리합니다.

![image](https://github.com/gather-around-and-code/study-js-deepdive/assets/67141218/b1fc8853-e725-476f-89bb-ff10e00d82b3)

**2.2 `this` 바인딩**
- 함수 환경 레코드의 `[[ThisValue]]` 내부 슬롯에 this가 바인딩됩니다. `[[ThisValue]]` 내부 슬롯에 바인딩될 객체는 함수 호출 방식에 따라 결정됩니다.
- `foo` 함수는 일반 함수로 호출되었으므로 `this`는 전역 객체를 가리킵니다.
- 따라서 함수 환경 레코드의 `[[ThisValue]]` 내부 슬롯에는 전역 객체가 바인딩됩니다.
- `foo` 함수 내부에서 `this`를 참조하면 함수 환경 레코드의 `[[ThisValue]]` 내부 슬롯에 바인딩되어 있는 객체가 바인딩됩니다.

![image](https://github.com/gather-around-and-code/study-js-deepdive/assets/67141218/3bb8e3c8-ee89-457a-b099-da4ed8bbfe91)

**2-3. 외부 렉시컬 환경에 대한 참조 결정**

> - 외부 렉시컬 환경에 대한 참조에 해당 함수의 정의가 평가된 시점에 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 할당됩니다.
> - 즉, 자바스크립트 엔진은 함수 정의를 평가하여 함수의 상위 스코프를 함수 객체의 내부 슬롯 `[[Environment]]`에 저장합니다.
> - 함수 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 할당되는 것은 함수의 상위 스코프를 가리키는 함수 객체의 내부 슬롯 `[[Environment]]`에 저장된 렉시컬 환경의 참조입니다.

![image](https://github.com/gather-around-and-code/study-js-deepdive/assets/67141218/c6e5ae7d-e6e7-4ab5-b5a4-6dbe541bebcc)

- `foo` 함수는 전역 코드에 정의된 전역 함수이고, 전역 코드 평가 시점에 평가되었기 때문에 평가 시점의 실행 중인 실행 컨텍스트는 전역 실행 컨텍스트입니다.
- 따라서 외부 렉시컬 환경에 대한 참조에는 전역 렉시컬 환경의 참조가 할당됩니다.

<br/>

### 23-6-5. `foo` 함수 코드 실행

- 런타임이 시작되어 소스코드가 순차적으로 실행되기 시작합니다.
- 실행 중인 실행 컨텍스트인 `foo` 함수 실행 컨텍스트에서 식별자 `a`, `x`, `y`, `bar`를 검색합니다.
  - 만약 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색할 수 없으면 상위 스코프로 이동하여 식별자를 검색합니다.
- 매개변수에 인수가 할당되고, 변수 할당문이 실행되어 지역 변수 `x`, `y`에 값이 할당됩니다. 그리고 함수 `bar`가 호출됩니다.

<br/>

### 23-6-6. `bar` 함수 코드 평가

- `bar` 함수가 호출되면 `foo` 함수 코드의 실행을 일시 중단하고 `bar` 함수 내부로 코드의 제어권이 이동합니다. 그리고 함수 코드를 평가하기 시작합니다.
- 실행 컨텍스트와 렉시컬 환경의 생성 과정은 `foo` 함수 코드 평가와 동일합니다.

<br/>

### 23-6-7. `bar` 함수 코드 실행

- 런타임이 시작되어 소스코드가 순차적으로 실행되기 시작합니다.
- 매개변수에 인수가 할당되고, 변수 할당문이 실행되어 지역 변수 `z`에 값이 할당됩니다.
- `console.log(a + b + x + y + z);`가 실행됩니다.
  
  - `console` 식별자 검색
    - `console` 식별자를 스코프 체인(실행 중인 실행 컨텍스트의 렉시컬 환경 ~ 외부 렉시컬 환경에 대한 참조로 이어지는 렉시컬 환경의 연속)에서 검색합니다.
    - 전역 렉시컬 환경의 객체 환경 레코드의 `BindingObject`를 통해 전역 객체에서 찾을 수 있습니다.
  - `log` 메서드 검색
    - `console` 객체의 프로토타입 체인을 통해 `log` 메서드를 검색합니다.
  - 표현식 `a + b + x + y + z`의 평가
    - 스코프 체인에서 식별자 `a`, `b`, `x`, `y`, `z`를 검색합니다.
  - `console.log` 메서드 호출
    - `a + b + x + y + z`가 평가되어 생성한 값 `42`를 메서드에 전달하여 호출합니다.

<br/>

### 23-6-8. `bar` 함수 코드 실행 종료

- 더 이상 실행할 코드가 없다면 함수 코드의 실행이 종료됩니다.
- 실행 컨텍스트 스택에서 `bar` 함수 실행 컨텍스트가 pop되어 제거되고 상위 실행 컨텍스트, `foo` 함수 실행 컨텍스트가 실행 중인 실행 컨텍스트가 됩니다.
- 실행 컨텍스트가 스택에서 해당 함수의 실행 컨텍스트가 제거되었다고 해서 함수 렉시컬 환경까지 즉시 소멸하는 것은 아닙니다.
- 렉시컬 환경은 실행 컨텍스트에 의해 참조되지만 독립적인 객체입니다. 객체를 포함한 모든 값이 누군가에의해 참조되지 않을 때 카비지 컬렉터에 의해 메모리 공간의 확보가 해제되어 소멸합니다.

<br/>

### 23-6-9. `foo` 함수 코드 실행 종료

- `bar` 함수가 종료하면 더 이상 실행할 코드가 없으므로 `foo` 함수 코드의 실행이 종료됩니다.
- 실행 컨텍스트 스택에서 `foo` 함수 실행 컨텍스트가 pop되어 제거되고 전역 실행 컨텍스트가 실행 중이 실행 컨텍스트가 됩니다.

<br/>

### 23-6-10. 전역 코드 실행 종료

- `foo` 함수가 종료하면 더 이상 실행할 전역 코드가 없으므로 전역 코드의 실행이 종료됩니다.
- 실행 컨텍스트 스택에서 전역 실행 컨텍스트가 pop되어 제거되고 실행 컨텍스트에는 아무것도 남아있지 않게 됩니다.

<br/>

## 23-7. 실행 컨텍스트와 블록 레벨 스코프

> - **`var`** 키워드로 선언한 변수는 함수의 코드 블록만 지역 스코프로 인정하는 **함수 레벨 스코프**
> - **`let`, `const`** 키워드로 선언한 변수는 모든 코드 블록을 지역 스코프로 인정하는 **블록 레벨 스코프**

```jsx
let x = 1;

if (true) {
  let x = 10;
  console.log(x); // 10
}

console.log(x); // 1
```

- `if` 문의 코드 블록 내에서 `let` 키워드로 변수가 선언되었으므로, `if` 문의 코드 블록이 실행되면 `if` 문의 코드 블록을 위한 블록 레벨 스코프를 생성해야 합니다.
- 선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성하여 기존의 전역 렉시컬 환경을 교체합니다.
- 이때 새롭게 생성된 `if` 문의 코드 블록을 위한 렉시컬 환경의 외부 렉시컬 환경에 대한 참조는 전역 렉시컬 환경을 가리킵니다.

  ![image](https://github.com/gather-around-and-code/study-js-deepdive/assets/67141218/cf4fa49f-0e51-4f97-a562-f14d27e5bb95)

- 코드 블록의 실행이 종료되면 원래의 렉시컬 환경으로 되돌립니다.
  
  ![image](https://github.com/gather-around-and-code/study-js-deepdive/assets/67141218/93f83d2a-ffc1-4035-9bbb-ba6a1e0a3e6a)
