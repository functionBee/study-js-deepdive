# 19장. 프로토타입(prototype)

JavaScript는 실제로 다중 패러다임 프로그래밍 언어로, 명령형, 함수형, 프로토타입 기반, 객체지향 프로그래밍을 지원합니다.

**[목차]**
19장. 프로토타입(prototype)

- [19장. 프로토타입(prototype)](#19장-프로토타입prototype)
  - [19-1. 객체지향 프로그래밍](#19-1-객체지향-프로그래밍)
  - [19-2. 상속과 프로토타입](#19-2-상속과-프로토타입)
  - [19-3. 프로토타입 객체](#19-3-프로토타입-객체)
    - [19-3-1. `__proto__` 접근자 프로퍼티](#19-3-1-__proto__-접근자-프로퍼티)
    - [19-3-2. 함수 객체의 prototype 프로퍼티](#19-3-2-함수-객체의-prototype-프로퍼티)
    - [19-3-3. 프로토타입의 `constructor` 프로퍼티와 생성자 함수](#19-3-3-프로토타입의-constructor-프로퍼티와-생성자-함수)
  - [19-4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입](#19-4-리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입)
  - [19-5. 프로토타입의 생성 시점](#19-5-프로토타입의-생성-시점)
    - [19-5.1 사용자 정의 생성자 함수와 프로토타입 생성 시점](#19-51-사용자-정의-생성자-함수와-프로토타입-생성-시점)
    - [19-5-2. 빌트인 생성자 함수와 프로토타입 생성 시점](#19-5-2-빌트인-생성자-함수와-프로토타입-생성-시점)
  - [19-6. 객체 생성 방식과 프로토타입의 결정](#19-6-객체-생성-방식과-프로토타입의-결정)
    - [19-6-1. 객체 리터럴에 의해 생성된 객체의 프로토타입](#19-6-1-객체-리터럴에-의해-생성된-객체의-프로토타입)
    - [19-6-2. Object 생성자 함수에 의해 생성된 객체의 프로토타입](#19-6-2-object-생성자-함수에-의해-생성된-객체의-프로토타입)
    - [19-6-3. 생성자 함수에 의해 생성된 객체의 프로토타입](#19-6-3-생성자-함수에-의해-생성된-객체의-프로토타입)
  - [19-7. 프로토타입 체인](#19-7-프로토타입-체인)
  - [19-8. 오버라이딩과 프로퍼티 새도잉](#19-8-오버라이딩과-프로퍼티-새도잉)
  - [19-9. 프로토타입의 교체](#19-9-프로토타입의-교체)
  - [19-10. `instanceof` 연산자](#19-10-instanceof-연산자)
  - [19-11. 직접 상속](#19-11-직접-상속)
  - [19-12. 정적 프로퍼티/메서드](#19-12-정적-프로퍼티메서드)
  - [19-13. 프로퍼티 존재 확인](#19-13-프로퍼티-존재-확인)
  - [19-14. 프로퍼티 열거](#19-14-프로퍼티-열거)
  - [참고](#참고)

<br>

## 19-1. 객체지향 프로그래밍

- 객체지향 프로그래밍은 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임입니다.
- 객체지향 프로그래밍은 실세계의 실체를 인식하는 철학적 사고를 프로그래밍에 접목한 개념입니다.
- 객체지향 프로그래밍에서 객체는 상태(state)와 행위(behavior)를 가집니다.
- 객체는 상태를 나타내는 데이터와 상태 데이터를 참조하고 조작할 수 있는 동작(메서드)을 행위로 포함합니다.
- 객체는 상태 데이터와 메서드를 하나의 논리적인 단위로 묶은 복합적인 자료구조입니다.
- 객체는 상태 데이터와 메서드를 캡슐화(encapsulation)합니다.
- 객체의 상태 데이터를 프로퍼티(property), 메서드를 메서드(method)라 부릅니다.

```jsx
// 예제 19-02
// 객체 리터럴
const circle = {
  radius: 5, // 프로퍼티
  // 원의 지름: 2r
  getDiameter() {
    // 메서드
    return 2 * this.radius;
  },
  // 원의 둘레: 2πr
  getPerimeter() {
    // 메서드
    return 2 * Math.PI * this.radius;
  },
  // 원의 넓이: πrr
  getArea() {
    // 메서드
    return Math.PI * this.radius ** 2;
  },
};

console.log(circle);
// {radius: 5, getDiameter: ƒ, getPerimeter: ƒ, getArea: ƒ}

console.log(circle.getDiameter()); // 10
console.log(circle.getPerimeter()); // 31.41592653589793
console.log(circle.getArea()); // 78.53981633974483
```

<br>

## 19-2. 상속과 프로토타입

<br>

## 19-3. 프로토타입 객체

<br>

### 19-3-1. `__proto__` 접근자 프로퍼티

<br>

### 19-3-2. 함수 객체의 prototype 프로퍼티

<br>

### 19-3-3. 프로토타입의 `constructor` 프로퍼티와 생성자 함수

<br>

## 19-4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

<br>

## 19-5. 프로토타입의 생성 시점

<br>

### 19-5.1 사용자 정의 생성자 함수와 프로토타입 생성 시점

<br>

### 19-5-2. 빌트인 생성자 함수와 프로토타입 생성 시점

<br>

## 19-6. 객체 생성 방식과 프로토타입의 결정

<br>

### 19-6-1. 객체 리터럴에 의해 생성된 객체의 프로토타입

<br>

### 19-6-2. Object 생성자 함수에 의해 생성된 객체의 프로토타입

<br>

### 19-6-3. 생성자 함수에 의해 생성된 객체의 프로토타입

<br>

## 19-7. 프로토타입 체인

<br>

## 19-8. 오버라이딩과 프로퍼티 새도잉

<br>

## 19-9. 프로토타입의 교체

<br>

## 19-10. `instanceof` 연산자

<br>

## 19-11. 직접 상속

<br>

## 19-12. 정적 프로퍼티/메서드

<br>

## 19-13. 프로퍼티 존재 확인

<br>

## 19-14. 프로퍼티 열거

<br>

## 참고

---
