# 5장. 표현식과 문(Expressions and Statements)
'모던 자바스크립트 Deep Dive'를 읽고 정리한 내용입니다. 

<br>

- [5장. 표현식과 문(Expressions and Statements)](#5장-표현식과-문expressions-and-statements)
  - [5-1. 값(Value)](#5-1-값value)
  - [5-2. 리터럴(Literal)](#5-2-리터럴literal)
  - [5-3. 표현식(Expression)](#5-3-표현식expression)
  - [5-4. 문(Statement)](#5-4-문statement)
  - [5-5. 세미콜론 자동 삽입기능(ASI;automatic semicolon insertion)](#5-5-세미콜론-자동-삽입기능asiautomatic-semicolon-insertion)
  - [5-6. 표현식인 문과 표현식이 아닌 문](#5-6-표현식인-문과-표현식이-아닌-문)
  - [요약](#요약)
  - [키워드](#키워드)
  - [Reference](#reference)

<br>

## 5-1. 값(Value)
- 값(value)은 표현식(expression)이 평가되어 생성된 결과를 말합니다.
- 평가(evaluation)는 표현식을 해석하여 값을 생성하거나 참조하는 것을 의미합니다.
- 값은 변수에 할당되거나 다른 표현식의 일부로 사용될 수 있습니다.
- 값은 리터럴(literal)이나 변수(variable) 등으로 생성될 수 있습니다.

```jsx

// 리터럴(literal) 값
10
"Hello, World!"
true
null
undefined

// 변수(variable) 값
let x = 10;
let y = "Hello, World!";
let z = true;
let w = null;
let v = undefined;

```

|   | 값을 생성할 수 있는 다양한 방법   |                 |
|:-:|:------------------------:|------------------------------|
| 1 | 리터럴(Literal)          | 리터럴은 값 자체를 직접 표현하는 방법입니다. - 예를 들어, 숫자 리터럴인  `42` , 문자열 리터럴인  `"Hello, World!"` , 불리언 리터럴인  `true`  또는  `false`  등이 있습니다.                |
| 2 | 변수(Variable)           | 변수는 값을 저장하고 참조하기 위해 사용되는 이름입니다. 변수를 선언하고 값을 할당하여 생성할 수 있습니다. - 예를 들어, `let x = 5;`와 같이 변수 `x`를 선언하고 값 `5`를 할당합니다.        |
| 3 | 연산자(Operator)         | 연산자를 사용하여 값을 생성할 수도 있습니다. - 예를 들어, 산술 연산자(`+`, `-`, `*`, `/` 등)를 사용하여 숫자를 계산하거나, 문자열 연결 연산자(`+`)를 사용하여 문자열을 결합할 수 있습니다. |
| 4 | 함수 호출(Function Call) | 함수를 호출하여 값을 생성할 수 있습니다. 함수는 입력(인자)을 받아서 특정 작업을 수행하고, 결과값을 반환합니다. 내장 함수 또는 사용자 정의 함수를 호출하여 값을 생성할 수 있습니다.         |
| 5 | 표현식(Expression)       | 변수, 리터럴, 연산자, 함수 호출 등의 조합으로 이루어지는 표현식은 값으로 평가될 수 있습니다.                                                                                               |

<br>

## 5-2. 리터럴(Literal)
- 리터럴(literal)은 사람이 이해할 수 있는 문자나 약속된 기호를 사용하여 값을 생성하는 표기법을 말합니다.
- 리터럴은 값 그 자체를 나타내며, 예를 들어, 숫자 리터럴은 숫자를 나타내는 기호이고, 문자열 리터럴은 따옴표로 둘러싸인 문자열을 나타냅니다.
- 리터럴은 변수에 할당되기 전에 이미 정해진 값을 나타냅니다.

```jsx
// 숫자 리터럴
let x = 5;      // 숫자 리터럴 5를 변수 x에 할당합니다.
let y = 3.14;   // 숫자 리터럴 3.14를 변수 y에 할당합니다.

// 문자열 리터럴
let str1 = "Hello, World!";   // 문자열 리터럴 "Hello, World!"를 변수 str1에 할당합니다.
let str2 = 'Hello, World!';   // 문자열 리터럴 'Hello, World!'를 변수 str2에 할당합니다.

// 불리언 리터럴
let isTrue = true;    // 불리언 리터럴 true를 변수 isTrue에 할당합니다.
let isFalse = false;  // 불리언 리터럴 false를 변수 isFalse에 할당합니다.

// null 리터럴
let foo = null;   // null 리터럴을 변수 foo에 할당합니다.

// undefined 리터럴
let bar = undefined;   // undefined 리터럴을 변수 bar에 할당합니다.
```

|   | 리터럴의 유형   | 의미                                           | 예                         |
|---|------------------| -----------------------------------------| ---------------------------|
| 1 | 숫자 리터럴(Number literal) | 정수나 실수 값을 나타냅니다.   | `42`, `3.14`, `0b1010(이진수)`, `0o755(8진수)`, `0xFF(16진수)` |
| 2 | 문자열 리터럴(String literal)    | 문자열 값을 나타냅니다. 따옴표(`"` 또는 `'`)로 둘러싸인 문자열입니다.   | `"Hello, world"`, `'abc'`, `'1232'` |
| 3 | 불린 리터럴(Boolean literal)      | 참(true) 또는 거짓(false) 값을 나타냅니다.    | `true`, `false`  |
| 4 | 배열 리터럴(Array literal)      | 여러 값을 순서대로 포함하는 배열을 나타냅니다. 대괄호([])로 둘러싸여 있으며, 쉼표로 구분된 값들의 목록입니다. | `[1, 2, 3]`, `['apple', 'banana', 'orange']`  |
| 5 | 객체 리터럴(Object literal)      | 중괄호(`{}`)로 둘러싸인 키-값 쌍의 모음을 나타냅니다. | `{ name: 'John', age: 30 }`    |
| 6 | 정규식 리터럴(RegExp literals)    | 속성-값 쌍으로 구성된 객체를 나타냅니다. 중괄호({})로 둘러싸여 있으며, 속성과 해당 값을 쉼표로 구분하여 나타냅니다.  | `const re = /ab+c/;` |

<br>

> **값(Value)과 리터럴(Literal)의 차이**:
> - 값은 데이터의 내용을 나타내는 것이고, 리터럴은 소스 코드에서 값을 표현하는 방식입니다.
> - 값은 변수에 저장되거나 다른 연산에 사용될 수 있습니다.
> - 리터럴은 소스 코드에서 고정된 값의 표현을 제공하며, 변수에 할당되기 전에 이미 정해진 값을 나타냅니다.

```javascript
// 값 예:
let age = 25;        // 값: 실제 데이터 25가 'age' 변수에 저장됩니다.
let name = "John";   // 값: 실제 문자열 "John"이 'name' 변수에 저장됩니다.
let isStudent = true;   // 값: 부울 값 'true'가 'isStudent' 변수에 저장됩니다.
let numbers = [1, 2, 3];   // 값: [1, 2, 3]의 배열이 'numbers' 변수에 저장됩니다.
let person = {
    name: "Alice",
    age: 30
};   // 값: 사람의 데이터를 나타내는 속성과 값이 있는 객체입니다.

// 리터럴 예:
let x = 5;      // 리터럴: 표기법 '5'가 숫자 값을 나타냅니다.
let greeting = "Hello";   // 리터럴: 표기법 "Hello"가 문자열 값을 나타냅니다.
let isActive = false;   // 리터럴: 표기법 'false'가 부울 값을 나타냅니다.
let colors = ["red", "blue", "green"];   // 리터럴: 표기법 ['red', 'blue', 'green']이 배열 값을 나타냅니다.
let regex = /pattern/;   // 리터럴: 표기법 /pattern/이 정규식을 나타냅니다.
```

<br>

## 5-3. 표현식(Expression)
- 표현식(expression)은 값으로 평가될 수 있는 문(statement)입니다.
- 값은 표현식이 평가되어 생성된 결과를 말합니다.
- 표현식은 연산자와 피연산자의 조합으로 이루어져 새로운 값을 생성하거나 기존 값을 참조합니다.

```jsx
// 리터럴 표현식
10
"Hello, World!"
true
null
undefined

// 식별자 표현식
sum
person.name
arr[1]

// 연산자 표현식
10 + 20
sum = 10
sum !== 10

// 함수/메서드 호출 표현식
square()
person.getName()
```

- 식별자 참조는 값으로 평가될 수 있는 표현식입니다.

```jsx
// 식별자 표현식
let x;   // 변수 선언문은 값으로 평가될 수 없습니다.
x = 1;   // 할당문은 값으로 평가될 수 없습니다.
x + 10;   // 표현식 x + 10은 값 11로 평가될 수 있습니다.
```

- 리터럴 표현식은 리터럴 그 자체로 값으로 평가될 수 있는 표현식입니다.

```jsx
// 리터럴 표현식
10;   // 숫자 리터럴은 값 10으로 평가될 수 있습니다.
"Hello";   // 문자열 리터럴은 값 "Hello"로 평가될 수 있습니다.
true;   // 불리언 리터럴은 값 true로 평가될 수 있습니다.
null;   // null 리터럴은 값 null로 평가될 수 있습니다.
undefined;   // undefined 리터럴은 값 undefined로 평가될 수 있습니다.
```

- 연산자 표현식은 피연산자를 연산하여 새로운 값을 생성하는 표현식입니다.

```jsx
// 산술 연산자 표현식
10 + 20;   // 덧셈 연산자 표현식은 피연산자 10과 20을 더한 후, 새로운 값을 생성합니다.
10 - 20;   // 뺄셈 연산자 표현식은 피연산자 10과 20을 뺀 후, 새로운 값을 생성합니다.
10 * 20;   // 곱셈 연산자 표현식은 피연산자 10과 20을 곱한 후, 새로운 값을 생성합니다.
10 / 20;   // 나눗셈 연산자 표현식은 피연산자 10을 20으로 나눈 후, 새로운 값을 생성합니다.
10 % 20;   // 나머지 연산자 표현식은 피연산자 10을 20으로 나눈 후, 나머지 값을 생성합니다.
++x;   // 증가 연산자 표현식은 피연산자 x의 값을 1 증가시킨 후, 새로운 값을 생성합니다.
--x;   // 감소 연산자 표현식은 피연산자 x의 값을 1 감소시킨 후, 새로운 값을 생성합니다.
```

- 할당 연산자 표현식은 우변의 피연산자를 좌변의 변수에 할당하는 표현식입니다.

```jsx
// 할당 연산자 표현식
x = 5;   // 할당 연산자 표현식은 우변의 피연산자 5를 좌변의 변수 x에 할당합니다.
```

- 비교 연산자 표현식은 좌항과 우항의 피연산자를 비교하여 불리언 값을 생성하는 표현식입니다.

```jsx
// 비교 연산자 표현식
10 > 20;   // 좌항의 피연산자 10이 우항의 피연산자 20보다 큰지 비교한 후, 불리언 값을 생성합니다.
10 < 20;   // 좌항의 피연산자 10이 우항의 피연산자 20보다 작은지 비교한 후, 불리언 값을 생성합니다.
10 >= 20;   // 좌항의 피연산자 10이 우항의 피연산자 20보다 크거나 같은지 비교한 후, 불리언 값을 생성합니다.
10 <= 20;   // 좌항의 피연산자 10이 우항의 피연산자 20보다 작거나 같은지 비교한 후, 불리언 값을 생성합니다.
10 == 20;   // 좌항의 피연산자 10이 우항의 피연산자 20과 같은지 비교한 후, 불리언 값을 생성합니다.
10 != 20;   // 좌항의 피연산자 10이 우항의 피연산자 20과 다른지 비교한 후, 불리언 값을 생성합니다.
```

- 논리 연산자 표현식은 좌항과 우항의 피연산자를 논리 연산하여 불리언 값을 생성하는 표현식입니다.

```jsx
// 논리 연산자 표현식
true && false;   // 논리 AND 연산자 표현식은 좌항의 피연산자 true와 우항의 피연산자 false를 논리 연산한 후, 불리언 값을 생성합니다.
true || false;   // 논리 OR 연산자 표현식은 좌항의 피연산자 true와 우항의 피연산자 false를 논리 연산한 후, 불리언 값을 생성합니다.
!true;   // 논리 NOT 연산자 표현식은 피연산자 true를 논리 연산한 후, 불리언 값을 생성합니다.
```

- 표현식은 값으로 평가되기 때문에 다른 표현식이나 문의 일부로 사용될 수 있습니다.

```jsx
// 표현식
10 + 20;   // 덧셈 연산자 표현식은 피연산자 10과 20을 더한 후, 새로운 값을 생성합니다.
x = 5;   // 할당 연산자 표현식은 우변의 피연산자 5를 좌변의 변수 x에 할당합니다.
x = 10 + 20;   // 덧셈 연산자 표현식은 피연산자 10과 20을 더한 후, 새로운 값을 생성합니다. 이 값은 변수 x에 할당됩니다.
```

> 문(Statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위입니다. 문은 프로그램의 동작을 지시하는 역할을 합니다. - 예)할당문, 조건문, 반복문

```jsx
// 문
let x;   // 변수 선언문은 값으로 평가될 수 없습니다.
x = 5;   // 할당문은 값으로 평가될 수 없습니다.
```

<br>

## 5-4. 문(Statement)
- 문(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위입니다.
- 문은 프로그램의 동작을 정의하고 실행됩니다.
- 문은 프로그램을 구성하는 요소로서 컴퓨터에게 내리는 명령이라고 할 수 있습니다.
- 문은 여러 토큰으로 구성되며, 토큰은 문법적인 의미를 가지고 있습니다.
- 문은 세미콜론(;)으로 종료하는 문과 자체 종결성(self closing)을 가지는 문으로 구분할 수 있습니다.
- 문은 실행 가능한 코드의 최소 단위이며, 문을 작성하고 순서에 맞게 나열하는 것을 프로그래밍이라고 합니다.

```jsx
// 변수 선언문
let x;

// 할당문
x = 5;

// 함수 선언문
function foo() {}

// 조건문
if (x > 5) {
  console.log("x는 5보다 큽니다.");
} else {
  console.log("x는 5보다 작거나 같습니다.");
}

// 반복문
for (var i = 0; i < 5; i++) {
  console.log(i);
}
```

<br>

## 5-5. 세미콜론 자동 삽입기능(ASI;automatic semicolon insertion)
- JavaScript와 같은 언어에서는 세미콜론을 명시적으로 작성하지 않아도 자동으로 삽입되는 기능을 가지고 있습니다.
- ASI는 개행 문자(줄 바꿈)를 기준으로 세미콜론을 삽입하는 규칙을 가지고 있습니다.
- 하지만 코드의 가독성과 오류 방지를 위해 명시적으로 세미콜론을 작성하는 것이 권장됩니다.

```jsx
// 세미콜론 자동 삽입 기능
let x
x
=
1
console.log(x)   // 1
```

<br>

## 5-6. 표현식인 문과 표현식이 아닌 문
- 표현식(expression)은 값으로 평가될 수 있는 문(statement)입니다.
- 표현식은 값으로 평가되기 때문에 다른 표현식이나 문의 일부로 사용될 수 있습니다.
- 표현식인 문과 표현식이 아닌 문을 구별하는 방법은 변수에 할당해 보는 것입니다.
- 변수에 할당할 수 있는 문은 표현식인 문입니다.
- 변수에 할당할 수 없는 문은 표현식이 아닌 문입니다.

```jsx
// 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아닌 문입니다.
let x;

// 1, 2, 1 + 2, x = 1 + 2는 모두 표현식이면서 완전한 문입니다.
x = 1 + 2;

// 표현식이 아닌 문은 값처럼 사용할 수 없습니다.
// 표현식이 아닌 문은 값처럼 사용할 수 없으므로 변수에 할당할 수 없습니다.
let foo = let x; // SyntaxError: Unexpected token 'let'

// 표현식인 문은 값처럼 사용할 수 있습니다.
let foo = x = 100;
console.log(foo); // 100
```

<br>


## 요약
- 값(value)은 표현식(expression)이 평가되어 생성된 결과를 말합니다.
- 리터럴(literal)은 사람이 이해할 수 있는 문자나 약속된 기호를 사용하여 값을 생성하는 표기법을 말합니다.
- 표현식(expression)은 값으로 평가될 수 있는 문(statement)입니다.
- 문(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위입니다.
- 표현식인 문과 표현식이 아닌 문을 구별하는 방법은 변수에 할당해 보는 것입니다.
- 변수에 할당할 수 있는 문은 표현식인 문입니다.
- 변수에 할당할 수 없는 문은 표현식이 아닌 문입니다.
- 세미콜론 자동 삽입 기능(ASI;automatic semicolon insertion)은 개행 문자(줄 바꿈)를 기준으로 세미콜론을 삽입하는 규칙을 가지고 있습니다.
- 하지만 코드의 가독성과 오류 방지를 위해 명시적으로 세미콜론을 작성하는 것이 권장됩니다.


<br>

## 키워드


| 키워드 | 의미 |
| :--- | :--- |
| 값(value) | 값은 표현식(expression)이 평가되어 생성된 결과를 말합니다.  예를 들어, 숫자 5, 문자열 "Hello, World!", 논리값 true/false는 모두 값입니다. |
| 표현식(expression) | 현식은 값으로 평가될 수 있는 문(statement)입니다. 표현식은 연산자와 피연산자의 조합으로 이루어져 새로운 값을 생성하거나 기존 값을 참조합니다. 예를 들어, 2 + 3은 덧셈 연산자와 피연산자 2, 3로 이루어진 표현식입니다. 이 표현식은 평가되면 값 5를 생성합니다. |
| 평가(evaluate) | 평가는 표현식을 해석하여 값을 생성하거나 참조하는 것을 의미합니다. 평가는 식을 실행하여 실제 결과를 얻는 과정을 말합니다. 예를 들어, 표현식 2 + 3을 평가하면 덧셈 연산이 실행되고 그 결과로 값 5가 생성됩니다. |
| 리터럴(literal) | 리터럴은 사람이 이해할 수 있는 문자나 약속된 기호를 사용하여 값을 생성하는 표기법을 말합니다. 리터럴은 값 그 자체를 나타내며, 예를 들어, 숫자 리터럴은 숫자를 나타내는 기호이고, 문자열 리터럴은 따옴표로 둘러싸인 문자열을 나타냅니다. |
| 표기법(notation) | 표기법은 값을 나타내는 방법이나 규칙을 의미합니다. |
| 런타임(runtime) | 런타임은 코드가 실행되는 시점을 의미합니다. 프로그램이 실행 중일 때의 상태와 동작을 말합니다. 코드의 실행 환경에서 실제로 동작하고 결과를 생성하는 시점을 런타임이라고 합니다. |
| 동치(equivalent) | 동치는 두 개체가 동등한 관계에 있는 것을 의미합니다. 여기서는 표현식과 표현식이 평가되는 값이 서로 동등한 관계에 있다는 의미로 사용되었습니다. |
| 문(statement) | 문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위입니다. 문은 프로그램의 동작을 지시하는 역할을 합니다. - 예)할당문, 조건문, 반복문 |
| 프로그램 | 프로그램은 문(statement)의 집합으로 이루어진 것을 말합니다. 프로그램은 실행 가능한 코드의 모음이며, 원하는 작업을 수행하는데 사용됩니다. 프로그램은 문들의 순서와 구조에 따라 동작합니다. |
| 프로그래밍 | 프로그래밍은 문을 작성하고 순서에 맞게 나열하는 것을 의미합니다. 프로그래밍은 프로그램을 작성하는 과정이나 스킬을 말합니다. 프로그래밍은 컴퓨터에게 원하는 동작을 지시하기 위해 알고리즘과 문법을 사용하여 코드를 작성하는 과정입니다. |
| 토큰(token) | 토큰은 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 기본 요소를 의미합니다. 예를 들어, 토큰은 예약어, 식별자, 연산자, 기호 등으로 구성됩니다. 프로그래밍 언어에서 코드는 토큰으로 구성되며, 이 토큰들이 문법적인 의미를 갖고 해석됩니다. |
| 자체 종결성(self closing) | 일부 문은 자체적으로 종결되기 때문에 세미콜론을 명시적으로 작성하지 않아도 됩니다. 이러한 문은 자체 종결성을 가지고 있으며, 예를 들어, JavaScript에서의 return 문과 break 문은 자체 종결성을 가지고 있습니다. |
| 세미콜론 자동 삽입기능(ASI;automatic semicolon insertion) | JavaScript와 같은 언어에서는 세미콜론을 명시적으로 작성하지 않아도 자동으로 삽입되는 기능을 가지고 있습니다. ASI는 개행 문자(줄 바꿈)를 기준으로 세미콜론을 삽입하는 규칙을 가지고 있습니다. 하지만 코드의 가독성과 오류 방지를 위해 명시적으로 세미콜론을 작성하는 것이 권장됩니다. |
| 정적 분석 도구 | 프로그램 코드를 분석하여 컴파일 타임이나 실행 타임 이전에 잠재적인 오류나 문제점을 찾아내는 도구를 말합니다. 정적 분석 도구는 코드 품질 향상, 버그 검출, 보안 강화 등을 위해 사용됩니다. - 예)ESLint |


<br>

## Reference

- [**Expressions and Operators - MDN Web Docs**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators)
- [**Statements - MDN Web Docs**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements)
- [**Literal - MDN Web Docs**](https://developer.mozilla.org/en-US/docs/Glossary/Literal)
- [**Literals - MDN Web Docs**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#literals)
- [**Literal on Wikipedia**](https://en.wikipedia.org/wiki/Literal_(computer_programming))