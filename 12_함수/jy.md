# 12장. 함수

## 12-1. 함수란?

함수는 자바스크립트를 정확히 이해하고 사용하기 위해 피해갈 수 없는 핵심 중의 핵심입니다.

- 함수는 **일련의 가정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것**입니다.
  
  - 매개변수 (parameter): 함수 내부로 입력을 전달받는 변수
  - 인수 (argument): 입력
  - 반환 값 (return value): 출력

- 함수는 **함수 정의**를 통해 생성합니다.

  ```jsx
  // 함수 정의
  function add(x, y) {
    return x + y;
  }
  ```

- 함수는 **함수 호출**을 통해 실행 결과, 즉 반환값을 반환합니다.
  
  ```jsx
  // 함수 호출
  var result = add(2, 5);
  console.log(result); // 7
  ```

<br>

## 12-2. 함수를 사용하는 이유

함수는 다음과 같은 특성을 가집니다.
- 함수의 실행 시점을 개발자가 결정할 수 있습니다.
- 함수는 몇 번이든 재사용이 가능합니다.

<br>

위와 같은 특성은 다음의 효과를 제공합니다.
- 코드의 재사용 측면에서 유용
- 유지보수의 편의성 향상
- 코드의 신뢰성 향상
- 함수의 역할을 잘 설명하는 이름을 부여하여 코드의 가독성 향상

<br>

## 12-3. 함수 리터럴

자바스크립트의 함수는 객체 타입의 값입니다. 따라서 함수도 함수 리터럴로 생성할 수 있습니다.

```jsx
// 변수에 함수 리터럴 할당
var f = function add(x, y) {
  return x + y;
};
```

- 함수 리터럴은 `function` 키워드, 함수 이름, 매개변수 목록, 함수 몸체로 구성됩니다.

  | 구성 요소     | 설명                                                         |
  | :-----------: | -------------------------------------------------------------|
  | 함수 이름     | - 함수 이름은 식별자 입니다. 따라서 식별자 네이밍 규칙을 준수해야 합니다.<br />- 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자입니다.<br />- 함수 이름은 생략 가능합니다. (이름이 있는 함수: 기명함수, 이름이 없는 함수: 무명/익명 함수) |
  | 매개변수 목록 | - 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분합니다.<br />- 각 매개변수에는 함수를 호출할 때 지정한 인수가 순서대로 할당됩니다.<br />- 매개변수는 함수 내에서 변수와 동일하게 취급됩니다. 따라서 식별자 네이밍 규칙을 준수해야 합니다. |
  | 함수 몸체     | - 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록입니다.<br />- 함수 몸체는 함수 호출에 의해 실행됩니다. |

- 함수 리터럴은 평가되어 값을 생성하며, 이 값은 객체입니다. 즉, 함수는 객체입니다.
  
  > 리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기 방식을 말합니다.
  
  - 함수는 일반 객체와는 다르게 호출할 수 있습니다. 
  - 함수는 일반 객체에는 없는 함수 객체만의 고유한 프로퍼티를 갖습니다.

<br>

## 12-4. 함수 정의

함수 정의란 함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들, 그리고 반환할 값을 지정하는 것을 말합니다.

정의된 함수는 자바스크립트 엔진에 의해 평가되어 함수 객체가 됩니다.

- **함수 선언문**

  ```jsx
  function add(x, y) {
    return x + y;
  }
  ```

- **함수 표현식**

  ```jsx
  var add = function (x, y) {
    return x + y;
  }
  ```

- **Function 생성자 함수**

  ```jsx
  var add = new Function('x', 'y', 'return x + y');
  ```

- **화살표 함수(ES6)**

  ```jsx
  var add = (x, y) => x + y;
  ```

<br>

### 12-4-1. **함수 선언문**
- 함수 선언문은 함수 리터럴과 형태가 동일하나, 함수 선언문은 함수 리터럴과 달리 함수 이름을 생략할 수 없습니다.
  
  ```jsx
  function (x, y) {
    return x + y;
  }
  // SyntaxError
  ```


- 기명 함수 리터럴은 코드의 문맥에 따라 함수 선언문 또는 함수 리터럴 표현식으로 해석됩니다.

  ```jsx
  var add = function add(x, y) {
    return x + y;
  }
  
  console.log(add(2, 5)); // 7
  ```
  
  함수 선언문은 표현식이 아닌 문이므로 값을 갖지 않습니다. 따라서 변수에 할당할 수 없습니다. 하지만 위 예제에서 함수가 변수에 할당되는 것 처럼 보입니다.
  이는 자바스크립트 엔진이 코드의 문맥에 따라 함수 선언문(표현식이 아닌 문)으로 해석하거나 함수 리터럴 표현식(표현식인 문)으로 해석하기 때문입니다. 

- 함수 선언문과 함수 리터럴 표현식은 함수를 생성하는 내부 동작에 차이가 있습니다.

  함수 선언문으로 생성된 `foo`는 호출할 수 있으나, 함수 리터럴 표현식으로 생성된 `bar`는 호출할 수 없습니다.
  
  > 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자 입니다. 즉, 함수 몸체 외부에서는 함수 이름으로 함수를 참조할 수 없습니다.
  
  ```jsx
  // 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석됩니다.
  // 함수 선언문에서는 함수 이름을 생략할 수 없습니다.
  function foo() {
    console.log('foo');
  }
  foo(); // foo
  ```
  
  ```jsx
  // 함수 리터럴은 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석됩니다.
  // 함수 리터럴에서는 함수 이름을 생략할 수 있습니다.
  (function bar() {
    console.log('bar');
  });
  bar(); // Reference Error
  ```
  
  - 함수 이름이 아닌, 함수를 가리키는 식별자가 없기 때문에 `bar`함수는 호출할 수 없습니다.
  - `foo`는 자바스크립트 엔진이 암묵적으로 생성한 식별자이므로 `foo`함수를 호출할 수 있습니다.
  
- 자바스크립트 엔진의 동작
  
  > **함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출합니다.**
  
  자바스크립트 엔진은 함수 선언문을 해석해 함수 객체를 생성합니다. 
  그리고 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당합니다.
  
  ```jsx
  function add(x, y) {
    return x + y;
  }

  // 자바스크립트 엔진은 다음과 같이 평가합니다.
  var add = function add(x, y) {
    return x + y;
  };
  ```
  
  결론적으로 자바스크립트 엔진은 함수 선언문을 함수 표현식으로 변환해 함수 객체를 생성한다고 생각할 수 있습니다.
  하지만 함수 선언문과 함수 표현식이 정확히 동일하게 동작하지는 않습니다. 함수 선언문은 '표현식이 아닌 문'이고 함수 표현식은 '표현식인 문'입니다.
  
<br>

### 12-4-2. **함수 표현식**

함수 리터럴로 생성한 함수 객체를 변수에 할당한 것을 함수 표현식이라고 합니다. 

- 일급 객체
  
  값의 성질을 갖는 객체를 의미합니다. 자바스크립트의 함수는 일급 객체입니다. 즉, 함수를 값처럼 자유롭게 사용할 수 있습니다.

- 익명 함수
  
  함수 리터럴의 함수 이름은 생략할 수 있습니다. 이러한 함수를 익명 함수라고 합니다. 함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적입니다.

- 함수 호출시 함수 이름이 아니라 함수 객체를 가리키는 식별자를 사용해야 합니다.
  
  ```jsx
  // 익명 함수 표현식
  var add = function (x, y) {
    return x + y;
  };

  // 기명 함수 표현식
  var add = function foo(x, y) {
    return x + y;
  };

  // 함수 객체를 가리키는 식별자 add로 호출
  console.log(add(2, 5)); // 7
  
  // 함수 이름으로 호출시 ReferenceError 발생
  // 함수 이름은 함수 몸체 내부에서만 유효
  console.log(foo(2, 5)); // ReferenceError: foo is not defined
  ```

<br>

### 12-4-3. **함수 생성 시점과 함수 호이스팅**

- 함수 선언문과 함수 표현식은 함수의 생성 시점이 다릅니다.

  > - 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있습니다.
  > - 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없습니다.

  ```jsx
  console.log(add(2, 5)); // 7
  console.log(sub(2, 5)); // TypeError (함수 참조시 undefined, undefined를 호출했으므로 TypeError)

  // 함수 호이스팅
  function add(x, y) {
    return x + y;
  }

  // 변수 호이스팅
  var sub = function (x, y) {
    return x + y;
  };
  ```

- 함수 선언문과 함수 표현식의 생성 시점
  
  | 함수 선언문 | 함수 표현식 |
  | :--------- | :--------- |
  | 함수 호이스팅이 발생합니다. | 변수 호이스팅이 발생합니다. |
  | 런타임 이전에 함수 객체가 생성됩니다. | 변수 선언은 런타임 이전에 undefined로 초기화됩니다. |
  | 런타임 이전에 생성된 함수 객체를 함수 이름과 동일한 식별자에 할당합니다.| 변수 할당문의 값(함수 리터럴)은 할당문이 실행되는 시점(런타임)에 평가되어 함수 객체가 됩니다. |
  
  > 함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 당연한 규칙을 무시하므로, 더글라스 크락포드는 함수 선언문 대신 함수 표현식을 사용할 것을 권장합다.

<br>

### 12-4-4. **Function 생성자 함수**

자바스크립트가 기본 제공하는 빌트인 함수인 `Function` 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 `new` 연산자와 함께 호출하면 함수 객체를 생성해서 반환합니다.

```jsx
var add = new Function("x", "y", "return x + y"); // new 연산자가 없어도 동일
console.log(add(2, 5)); // 7
```

> 일반적이지도, 바람직하지도 않습니다. `Function` 생성자 함수로 생성한 함수는 클로저를 생성하지 않는 등 함수 선언문/표현식으로 생성한 함수와 다르게 동작합니다.

<br>

### 12-4-5. **화살표 함수**

ES6에 도입된 화살표 함수(arrow function)은 `function` 키워드 대신 화살표 `=>`를 사용해 좀 더 간략한 방법으로 함수를 선언할 수 있습니다.
화살표 함수는 항상 익명 함수로 정의합니다.

```jsx
var add = (x, y) => x + y;
console.log(add(2, 5)); // 7
```

> - 기존 함수보다 표현만 간략한 것이 아니라 내부 동작 또한 간략화 되어 있습니다.
> - 생성자 함수로 사용할 수 없습니다.
> - 기존 함수와 `this` 바인딩 방식이 다릅니다.
> - `prototype` 프로퍼티가 없습니다.
> - `arguments` 객체를 생성하지 않습니다.

<br>

## 12-5. 함수 호출

함수는 함수를 가리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자`()`로 호출합니다.

### 12-5-1. **매개변수와 인수**

- 매개변수는 함수를 정의할 때 선언하며, 함수 몸체 내부에서 변수와 동일하게 취급됩니다. 
  함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 새성되고, 일반 변수와 마찬가지로 `undefined`로 초기화된 후 인수가 순서대로 할당됩니다.
  
  ```jsx
  function add(x, y) {
    return x + y;
  }

  // 인수 1, 2가 매개변수 x, y에 순서대로 할당되고 함수 몸체의 문들이 실행됩니다.
  var result = add(1, 2);
  ```

- 매개변수의 스코프는 함수 내부입니다.

  ```jsx
  function add(x, y) {
    return x + y;
  }

  // add 함수의 매개변수 x, y는 함수 몸체 내부에서만 참조할 수 있습니다.
  console.log(x, y); // ReferenceError
  ```

- 인수가 부족해도 에러가 발생하지 않습니다. 할당되지 않은 매개변수의 값은 `undefined` 입니다.
 
  ```jsx
  function add(x, y) {
    return x + y;
  }
  
  console.log(add(2)); // NaN
  ```

- 초과된 인수는 무시됩니다. 암묵적으로 `arguments` 객체의 프로퍼티로 보관됩니다.

  ```jsx
  function add(x, y) {
    return x + y;
  }
  
  console.log(add(2, 5, 10)); // 7
  ```

  > arguments 객체는 함수를 정의할 때 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용하게 사용됩니다.

<br>

### 12-5-2. **인수 확인**
- 어떤 타입의 인수를 전달해야 하는지, 어떤 타입의 값을 반환하는지 명확하지 않습니다.
  
  - 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않습니다.
  - 자바스크립트는 동적 타입 언어로, 매개변수의 타입을 지정할 수 없습니다.
  
  ```jsx
  function add(x, y) {
    return x + y;
  }

  console.log(add(2)); // NaN
  console.log(add('a', 'b')); // 'ab'
  ```

- 따라서 함수를 정의할 때 적절한 인수가 전달되었는지 확인할 필요가 있습니다.

  - 타입스크립트를 사용하는 것도 하나의 방법입니다.
  - `arguments` 객체를 통해 인수 개수를 확인할 수도 있습니다.
  - 인수가 전달되지 않은 경우 단축 평가를 사용해 매개변수에 기본 값을 할당하는 방법도 있습니다. `a = a || 0;`
  - 매개변수 기본값을 사용해 인수 체크 및 초기화를 할 수 있습니다. `function foo(a = 0){...}`

<br>

### 12-5-3. **매개변수의 최대 개수**

ECMAScript 사양에서는 매개변수의 최대 개수에 대해 명시적으로 제한하고 있지는 않습니다.

- **매개변수는 순서에 의미가 있습니다.**
  
  - 매개변수가 많아지면 함수를 호출할 때 전달해야 할 인수의 순서를 고려해야 하고, 이로 인해 함수 사용법 이해가 어려워지고 실수를 발생시킬 가능성을 높입니다.
  - 매개변수의 개수나 순서가 변경되면 함수의 호출 방법도 바뀌므로 함수를 사용하는 코드 전체가 영향을 받습니다. 즉, 유지보수성이 나빠집니다.

- **이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 합니다.**
  
  - 매개변수는 적을수록 좋으며, 최대 3개 이상을 넘지 않는 것을 권장합니다.
  - 그 이상이 필요하다면 하나의 매개변수를 선언해 객체를 인수로 전달하는 것이 유리합니다.
    
    - 객체를 인수로 사용하는 경우 프로퍼티 키만 정확히 지정하면 매개변수의 순서를 신경쓰지 않아도 됩니다.
    - 함수 외부에서 함수 내부로 전달한 객체를 함수 내부에서 변경하면 함수 외부의 객체가 변경되는 부수 효과가 발생하므로 주의해야 합니다.

<br>

### 12-5-4. **반환문**

함수는 `return` 키워드와 표현식(반환값)으로 이뤄진 반환문을 사용해 실행 결과를 함수 외부로 반환할 수 있습니다.

```jsx
function multiply(x, y) {
  return x * y; // 반환문
}

// 함수 호출은 반환값으로 평가됩니다.
var result = multiply(3, 5);
console.log(result); // 15
```

- 반환문의 역할
  
  - 함수의 실행을 중단하고 함수 몸체를 빠져나갑니다.
  - `return` 키워드 뒤에 오는 표현식을 평가해 반환합니다. 표현식을 명시적으로 지정하지 않으면 `undefined`가 반환됩니다.

- 반환문은 생략할 수 있습니다. 이때 암묵적으로 `undefined`를 반환합니다.
  
  ```jsx
  function foo () {
  }
  console.log(foo()); // undefined
  ```

- `return` 키워드와 표현식 사이에 줄바꿈이 있을 경우 세미콜론이 자동 삽입되어 주의해야 합니다.
  
  ```jsx
  function multiply(x, y) {
    return 
    x * y;
  }
  console.log( multiply(3, 5)); // undefined
  ```
  
- 반환문은 함수 몸체 내부에서만 사용할 수 있습니다. 전역에서 반환문을 사용하면 문법 에러가 발생합니다.

<br>

## 12-6. 참조에 의한 전달과 외부 상태의 변경

매개변수도 함수 몸체 내부에서 변수와 동일하게 취급되므로 매개변수 또한 타입에 따라 값에 의한 전달, 참조에 의한 전달 방식을 그대로 따릅니다.

```jsx
function changeVal(primitive, obj) {
  primitive += 100;
  obj.name = 'Kim';
}

var num = 100;
var person = { name: 'Lee' };

console.log(num); // 100
console.log(person); // { name: 'Lee' }

// 원시 값은 값 자체가 복사되어 전달되고 객체는 참조 값이 복사되어 전달됩니다.
changeVal(num, person);

// 원시 값은 원본이 훼손되지 않습니다.
console.log(num); // 100

// 객체는 원본이 회손됩니다.
console.log(person); // { name: 'Lee' }
```

- 원시 타입 인수
  
  값 자체가 복사되어 매개변수에 전달되므로 함수 몸체에서 그 값을 변경(재할당을 통한 교체)해도 원본이 훼손되지 않습니다.

- 객체 타입 인수
  
  참조 값이 복사되어 매개변수에 전달되므로 함수 몸체에서 그 값을 변경(재할당을 통한 교체)해도 원본이 훼손됩니다.
  
  이 경우 상태 변화를 추적하기 어려워져 코드의 복잡성을 증가시키고 가독성을 해치는 원인이 됩니다.
  
  - 옵저버 패턴 등의 대응이 필요합니다.
  - 혹은 객체를 원시 값 처럼 변경 불가능한 값으로 동작하게 만듭니다.
    (객체의 복사본을 새롭게 생성(deep copy)하는 비용 발생)

- 순수 함수

  - 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수를 말합니다.
  - 순수 함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍 패러다임을 함수형 프로그래밍이라 합니다.

<br>

## 12-7. 다양한 함수의 형태

### 12-7-1. **즉시 실행 함수**

함수 정의와 동시에 즉시 호출되는 함수를 말합니다. 즉시 실행 함수는 단 한번만 호출되며 재호출할 수 없습니다.

- 익명 즉시 실행 함수가 일반적입니다.
 
  ```jsx
  // 익명 즉시 실행 함수
  (function () {
    var a = 3;
    var b = 5;
    return a * b;
  })();
  ```

- 그룹 연산자 내 기명 함수를 쓸 경우 함수 리터럴로 평가되어 즉시 실행 함수를 다시 호출할 수 없습니다.

  ```jsx
  // 기명 즉시 실행 함수
  (function foo() {
    var a = 3;
    var b = 5;
    return a * b;
  })();

  foo(); // ReferenceRrror: foo is not defined
  ```

- 반드시 그룹 연산자`(...)`로 감싸야 합니다. 그렇지 않으면 에러가 발생합니다.
  
  ```jsx
  // 함수의 선언문은 함수 이름을 생략할 수 없습니다.
  function() { ... } (); // SyntaxError: Function Statements require a function name.
  
  // 중괄호 뒤에 ";"이 암묵적으로 추가됩니다. 
  // 따라서 (...)가 호출 연산자가 아닌 그룹 연산자로 해석되고, 그룹 연산자에 피연산자가 없어 에러가 발생합니다.
  function foo() { ... } (); // SyntaxError: Unexpected token ')'
  ```
  
- 그룹 연산자의 피연산자는 값으로 평가므로 함수 리터럴로 평가되어 함수 객체가 생성됩니다.
  
  ```jsx
  console.log(typeof (function f(){})); // function
  console.log(typeof (function (){})); // function
  ```

- 가능한 방식

  ```jsx
  (function () {
    ...
  }());

  (function () {
    ...
  })();

  !function () {
    ...
  }();

  +function () {
    ...
  }();
  ```

- 즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있고 인수를 전달할 수 있습니다.

  ```jsx
  var res = (function () {
    var a = 3;
    var b = 5;
    return a * b;
   }());
   
   console.log(res); // 15
   
   // 즉시 실행 함수에도 일반 함수처럼 인수를 전달할 수 있습니다.
   res  = (function (a, b) {
    return a * b;
   }(3, 5));
   
  console.log(res); // 15
  ```

- 즉시 실행 함수 내에 코드를 모아 두면 혹시 있을 수 있는 변수/함수 이름의 충돌을 방지할 수 있습니다.

<br>

### 12-7-2. **재귀 함수**

함수가 자기 자신을 호출하는 것을 재귀 호출이라 한다. 재귀 함수는 재귀 호출을 수행하는 함수를 말합니다.

- 함수 내부에서는 함수 이름을 사용해 재귀 호출이 가능합니다.
- 함수 외부에서는 함수를 가리키는 식별자로 호출해야 합니다.

  ```jsx
  // 반복문
  function countdown(n) {
    for (var i = n; i >= 0; i--) console.log(i);
  }

  countdown(10);

  // 재귀 함수
  function countdown(n) {
    if (n < 0) return;
    console.log(n);
    countdown(n - 1); // 재귀 호출
  }

  countdown(10);
  ```

- 재귀 함수는 재귀 호출을 멈출 수 있는 **탈출 조건**을 반드시 만들어야 합니다.

  - 재귀 함수는 반복되는 처리를 반복문 없이 구현할 수 있지만, 무한 반복에 빠질 수 있고 이로 인한 `스택 오버플로 에러`를 발생시킬 수 있으므로 주의해야 합니다.
  - 반복문보다 재귀함수를 사용하는 편이 더 직관적으로 이해하기 쉬울 때만 한정적으로 사용하는 것이 바람직합니다.

<br>

### 12-7-3. **중첩 함수**

함수 내부에 정의된 함수를 중첩 함수 또는 내부 함수라고 합니다.

> ES6부터는 `if` 문이나 `for` 문 등의 코드 블록 내에서도 (함수 선언문을) 정의할 수 있지만, 바람직하지 않습니다.

- 중첩 함수를 포함하는 함수는 외부 함수라 부릅니다.
- 중첩 함수는 외부 함수 내부에서만 호출할 수 있습니다.
- 일반적으로 중첩 함수는 자신을 포함하는 외부 함수를 돕는 헬퍼 함수 역할을 합니다.
  
```jsx
function outer() {
  var x = 1;

  // 중첩 함수
  function inner() {
    var y = 2;
    // 외부 함수의 변수 참조
    console.log(x + y);
  }

  inner();
}

outer();
```

<br>

### 12-7-4. **콜백 함수**

함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라고 합니다.

- 매개 변수를 통해 함수 외부에서 콜백 함수를 전달받은 함수를 **고차 함수**라고 합니다.
- 콜백 함수는 고차 함수에 전달되어 헬퍼 함수의 역할을 합니다.
- 고차 함수는 콜백 함수를 자신의 일부분으로 합성합니다.

  ```jsx
  // repeat 함수는 내부 로직에 의존하지 않고 
  // 외부에서 로직의 일부분을 함수로 전달받아 수행하므로 더욱 유연한 구조를 가집니다.
  // 고차 함수
  function repeat(n, f) {
    for (var i = 0; i < n; i++) f(i);
  }

  // 콜백 함수
  var logAll = function (i) {
    console.log(i);
  };

  repeat(5, logAll);

  // 콜백 함수
  var logOdds = function (i) {
    if (i % 2) console.log(i);
  };

  repeat(5, logOdds);
  ```

- 고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출합니다.
  
  -  콜백 함수는 고차 함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있습니다.

- 콜백 함수가 고차 함수 내부에만 호출된다면 콜백 함수를 익명 함수 리터럴로 정의하면서 곧바로 고차 함수에 전달하는 것이 일반적입니다.
  
  - 이때 콜백 함수로서 전달된 함수 리터럴은 고차 함수가 호출될 때마다 평가되어 함수 객체를 생성합니다.

  ```jsx
  repeat(5, function (i) {
    if (i % 2) console.log(i);
  }); // 1 3
  ```

- 콜백 함수는 함수형 프로그래밍 패러다임, 비동기 처리(이벤트 처리, Ajax 통신, 타이머 함수 등)에 활용되는 중요한 패턴입니다.

  ```jsx
  document.getElementById('myButton').addEventListener('click', function () {
    console.log('button clicked!');
  }
  
  setTimeout(function () {
    console.log('1초 경과');
  }, 1000);
  ```

- 콜백 함수는 비동기 처리뿐 아니라 배열 고차 함수(map, filter, reduce)에서도 사용됩니다.

  ```jsx
  var res = [1, 2, 3].map(function (item) {
    return item * 2;
  });
  
  console.log(res); // [2, 4, 6]
  
  res = [1, 2, 3].map(function (item) {
    return item % 2;
  });
  
  console.log(res); // [1, 3]
  
  res = [1, 2, 3].map(function (acc, cur) {
    return acc + cur;
  }, 0);
  
  console.log(res); // 6
  ```

<br>

### 12-7-5. **순수 함수와 비순수 함수**

- **순수 함수**
  - 어떤 외부 상태에 의존하지도 변경하지도 않는, 부수 효과가 없는 함수
  - 동일한 인수가 전달되면 동일한 값을 반환합니다.
  - 최소 하나 이상의 인수를 전달 받습니다. (인수를 전달받지 않으면 상수와 마찬가지)
  - 인수의 불변성을 유지합니다.

- **비순수 함수**
  - 외부 상태에 의존하거나 외부 상태를 변경하는, 부수 효과가 있는 함수
  - 함수 외부 상태(전연 변수, 서버 데이터, 파일, Console, DOM)에 따라 반환 값이 달라집니다.
  - 인수를 전달받지 않고 함수 내부에서 외부 상태를 직접 참조하는 경우 비순수 함수가 됩니다.
  - 상태 변화를 추적하기 어려워지고 코드의 복잡성을 증가시킵니다. 

- **함수형 프로그래밍**
  - 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화해서 불변성을 지향하는 프로그래밍 패러다임
  - 로직 내 조건문, 반복문을 제거해 복잡성 해결하는 것을 목표합니다. (가독성)
  - 변수 사용 억제, 생명주기 최소화로 상태 변경을 피해 오류를 최소화하는 것을 목표합니다. (오류의 근본적 원인)
