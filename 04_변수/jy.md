# 4장. 변수

- **변수(variable)**

  변수는 **값의 위치를 가리키는 상징적인 이름**입니다. 하나의 값을 저장하기 위해 확보한 메모리 공간 자체를 의미하기도 합니다. 변수는 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행됩니다.
  
  - 할당: 변수에 값을 저장하는 것
  - 참조: 변수에 저장된 값을 읽어들이는 것
  
  <br>
  
  ```javascript
  // cur: 변수 이름, 100: 변수 값
  // = 를 사용하여 변수 이름에 변수 값을 할당
  const cur = 100; 
  
  // next: 변수 이름, 100 + 1: 변수 값
  // cur를 참조하여 변수 이름에 100 + 1을 할당
  const next = cur + 1; 
  ```
  
  > 변수 이름은 변수 존재 목적을 쉽게 이해할 수 있도록 의미를 명확히 표현해야 합니다. 좋은 변수 이름은 코드의 가독성을 높입니다. 변수 선언에 별도의 주석이 필요하다면 변수의 존재 목적을 명확히 드러내지 못하는 것입니다.
  
<br>

- **식별자(identifier)**
  
  **프로그램의 어떤 요소와 연관된 이름**을 의미합니다. 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자라고 합니다.
  
    ```javascript
    // 변수 식별자 (값과 연관)
    let score = 50;
    
    // 함수 식별자 (함수와 연관)
    function getScore() {
      return 100;
    }
    
    // sum, len: 파라메터 식별자 (인자값과 연관)
    function getAverage(sum, len) {
      return sum / len;
    }
    
    // 클래스 식별자 (클래스와 연관)
    class person {
      name; // 필드 식별자 (필드값과 연관)
      age;
      speak(); // 메소드 식별자 (메소드와 연관)
    }
    ```
  
  - 식별자는 **값이 아니라 메모리 주소를 기억**하고 있습니다. 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근합니다.

  - 식별자는 **네이밍 규칙**을 준수해야 합니다.
    - 식별자는 특수문자(% * @ ^ 등)를 포함할 수 없습니다. 단, 언더스코어(_), 달러기호($)는 포함할 수 있습니다.
    - 식별자는 공백을 포함할 수 없습니다.
    - 식별자는 대소문자를 구분합니다. **`name`** 과 **`Name`** 은 서로 다른 식별자 입니다.
    - 식별자는 숫자로 시작할 수 없습니다.
    - 예약어(await, break, case, catch 등)는 식별자로 사용할 수 없습니다.
    - 식별자는 대소문자를 구분합니다.

  - **네이밍 컨벤션**(naming convention)을 잘 지키면 읽기 좋은 식별자를 만들 수 있습니다. 
    자바스크립트에서는 일반적으로 변수나 함수의 이름에는 카멜 케이스를 사용하고, 생성자 함수, 클래스의 이름에는 파스칼 케이스를 사용합니다.
    
    ```javascript
    // 카멜 케이스(camelCase)
    var firstName;
    
    // 스네이크 케이스(snake_case)
    var first_name;
    
    // 파스칼 케이스(PascalCase)
    var FirstName;
    
    // 헝가리언 케이스(typeHungarianCase)
    var strFirstName; // type + identifier
    var $elem = document.getElmentById('myId'); // DOM 노드
    var observable$ = fromEvent(document, 'click'); // RsJS 옵저버블
    ```

<br>

- **변수 선언(variable declaration)**
  
  변수 선언이란 **변수를 생성하는 것**을 의미합니다. 값을 저장하기 위한 메모리 공간을 확보하고, 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것입니다.
  
  - 변수를 사용하려면 반드시 선언이 필요합니다. 만약 변수를 선언하지 않았는데 참조하려고 하면 참조 에러(ReferenceError)가 발생합니다.
  
    ```javascript
    var score; // 변수 선언
    console.log(name); // Reference Error
    ```
    
  - 자바스크립트 엔진은 변수 선언을 2단계에 거쳐 수행합니다.
    - 선언 단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알립니다.
    - 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화합니다.

  - 변수를 사용하기 위해 **`var`** , **`let`** , **`const`** 키워드를 사용합니다.
    1. **`var`** 키워드
        - ES5 까지 존재했던 유일한 변수 선언을 위한 키워드
        - 함수 레벨 스코프를 지원
        - 변수 재선언 가능
        - 값 재할당 가능
        - 선언 단계와 초기화 단계 동시 진행
    2. **`let`** 키워드
        - ES6 부터 도입된 키워드
        - 블록 레벨 스코프를 지원
        - 변수 재선언 불가능
        - 값 재할당 가능
    3. **`const`** 키워드
        - ES6 부터 도입된 키워드
        - 블록 레벨 스코프를 지원
        - 변수 재선언 불가능
        - 값 재할당 불가능(상수)
  
<br>

- **변수 선언의 실행 시점과 변수 호이스팅(variable hoisting)**
  
  변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행됩니다.
  
  ```javascript
  console.log(score); // undefined
  var score; // 변수 선언문
  ```  
  
  자바스크립트 엔진은 **런타임 이전에 먼저 소스코드 평가 과정**을 거치면서 소스코드를 실행하기 위한 준비를 합니다. 이때, **모든 선언문(변수 선언문, 함수 선언문 등)을 소스코드에서 찾아내 먼저 실행**합니다.
  그리고 평가과정이 끝나면 모든 선언문을 제외한 소스코드를 한 줄씩 순차적으로 실행합니다. 즉, 선언문이 다른 코드보다 먼저 실행됩니다.
  
  이처럼 변수 선언문이 코드의 선두로 '끌어 올려진 것처럼' 동작하는 자바스크립트 고유의 특징을 변수 **호이스팅**이라고 한다. 실제로 코드가 끌어올려지는 것은 아닙니다.
  주의해야할 점은 할당이 아닌 선언만 호이스팅된다는 것입니다.
  
<br>

- **값의 할당(assignment)**
  
  변수에 값을 할당할 때는 할당 연산자 **`=`** 를 사용합니다.
  
  ```javascript
  var score;  // 변수 선언
  score = 80; // 값의 할당
  
  var score = 80; // 변수 선언과 값의 할당 동시에
  ```  
  
  변수 선언은 런타임 이전에 먼저 실행되지만, 값의 할당은 런타임에 실행됩니다.
  
  ```javascript
  console.log(score); // undefined
  var score = 80;     // 변수 선언과 값의 할당
  console.log(score); // 80
  ```  
  
  ```javascript
  console.log(score); // undefined
  score = 80;
  var score;
  console.log(score); // 80
  ```  
  
<br>

- **값의 재할당**
  
  값의 재할당이란 이미 값이 할당되어 있는 변수에 새로운 값을 다시 할당하는 것을 의미합니다.
  
  ```javascript
  var score = 80; // 변수 선언과 값의 할당
  score = 90;     // 값의 재할당
  ```  
  
  - **`var`** 키워드로 선언한 변수는 선언과 동시에 undefined로 초기화되기 때문에 엄밀히 말하자면 변수에 처음으로 값을 할당하는 것도 재할당입니다.
  - **`const`** 는 값을 재할당할 수 없어 상수입니다.
  - **`var`** 변수에 값을 재할당하면 이전 값이 저장되어있던 메모리 공간을 지우고 거기에 값을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 할당 값을 저장합니다.
  - 이렇게 사용하지 않게 되는 메모리 공간은 **`가비지 콜렉터`** 에 의해 자동 해제됩니다. 단, 메모리에서 언제 해제될지는 예측할 수 없습니다.
  
  <br>
  
  > 가비지 콜렉터(garbage collector)는 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능을 의미합니다.
